<!-- - var pageType = is_post() ? 'post' : 'page'--><!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>仿牛客论坛项目——相关功能介绍 | 山花终将烂漫</title><meta name="author" content="未闻花名"><meta name="copyright" content="未闻花名"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="仿牛客论坛项目介绍">
<meta property="og:type" content="article">
<meta property="og:title" content="仿牛客论坛项目——相关功能介绍">
<meta property="og:url" content="http://www.ccjinblog.top/2025/04/11/2025_4/00%20%E9%A1%B9%E7%9B%AE/index.html">
<meta property="og:site_name" content="山花终将烂漫">
<meta property="og:description" content="仿牛客论坛项目介绍">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://source.fomal.cc/img/default_cover_4.webp">
<meta property="article:published_time" content="2025-04-10T16:00:00.000Z">
<meta property="article:modified_time" content="2026-02-08T02:51:32.974Z">
<meta property="article:author" content="未闻花名">
<meta property="article:tag" content="java">
<meta property="article:tag" content="就业">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://source.fomal.cc/img/default_cover_4.webp"><link rel="shortcut icon" href="https://www.fomal.cc/favicon.ico"><link rel="canonical" href="http://www.ccjinblog.top/2025/04/11/2025_4/00%20%E9%A1%B9%E7%9B%AE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: 未闻花名","link":"链接: ","source":"来源: 山花终将烂漫","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '仿牛客论坛项目——相关功能介绍',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/config/css/font.css"><link rel="stylesheet" href="/config/css/bolang.css"><link rel="stylesheet" href="/config/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/config/css/progress_bar.css"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><script src="/config/js/chart.js"></script><span id="fps"></span><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><!--//源代码--><!--if theme.preloader.enable--><!--  if theme.preloader.source === 1--><!--    include ./fullpage-loading.pug--><!--  else--><!--    include ./pace.pug--><!--//源代码--><!--#loading-box--><!--  .loading-left-bg--><!--  .loading-right-bg--><!--  .spinner-box--><!--    .configure-border-1--><!--      .configure-core--><!--    .configure-border-2--><!--      .configure-core--><!--    .loading-word= _p('loading')--><!----><!--script.--><!--  (()=>{--><!--    const $loadingBox = document.getElementById('loading-box')--><!--    const $body = document.body--><!--    const preloader = {--><!--      endLoading: () => {--><!--        $body.style.overflow = ''--><!--        $loadingBox.classList.add('loaded')--><!--      },--><!--      initLoading: () => {--><!--        $body.style.overflow = 'hidden'--><!--        $loadingBox.classList.remove('loaded')--><!--      }--><!--    }--><!----><!--    preloader.initLoading()--><!--    window.addEventListener('load', preloader.endLoading)--><!----><!--    if (!{theme.pjax && theme.pjax.enable}) {--><!--      btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')--><!--      btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')--><!--    }--><!--  })()--><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="/source/config/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(https://ccjinblog.oss-cn-beijing.aliyuncs.com/blogiamge/20250120102746537.webp);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ccjinblog.oss-cn-beijing.aliyuncs.com/blogiamge/20250123182424614.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa-solid fa-house"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa-solid fa-newspaper"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fab fa-grav"></i><span> 图表</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fa fa-camera-retro fa-lg"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://source.fomal.cc/img/default_cover_4.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ccjinblog.oss-cn-beijing.aliyuncs.com/blogiamge/20250123182604153.webp" alt="Logo"><span class="site-name">山花终将烂漫</span></a><a class="nav-page-title" href="/"><span class="site-name">仿牛客论坛项目——相关功能介绍</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa-solid fa-house"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa-solid fa-newspaper"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fab fa-grav"></i><span> 图表</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fa fa-camera-retro fa-lg"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">仿牛客论坛项目——相关功能介绍</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-10T16:00:00.000Z" title="发表于 2025-04-11 00:00:00">2025-04-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-02-08T02:51:32.974Z" title="更新于 2026-02-08 10:51:32">2026-02-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">16.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2026-02-08 10:51:32&quot;}" hidden></div><h1 id="项目相关功能介绍："><a href="#项目相关功能介绍：" class="headerlink" title="项目相关功能介绍："></a>项目相关功能介绍：</h1><h2 id="介绍一下项目："><a href="#介绍一下项目：" class="headerlink" title="介绍一下项目："></a>介绍一下项目：</h2><p>这个项目的整体结构来源于牛客网，主要使用了Springboot、Mybatis、MySQL、Redis、Kafka、等工具。主要实现了用户的注册、登录、发帖、点赞、系统通知、按热度排序、搜索等功能。另外引入了redis数据库来提升网站的整体性能，实现了用户凭证的存取、点赞关注的功能。基于 Kafka 实现了系统通知：当用户获得点赞、评论后得到通知。利用定时任务定期计算帖子的分数，并在页面上展现热帖排行榜。</p>
<h2 id="一、-发送邮件功能："><a href="#一、-发送邮件功能：" class="headerlink" title="一、 发送邮件功能："></a>一、 发送邮件功能：</h2><h3 id="01-你如何在-Spring-Boot-项目中实现发送邮件的功能？"><a href="#01-你如何在-Spring-Boot-项目中实现发送邮件的功能？" class="headerlink" title="01 你如何在 Spring Boot 项目中实现发送邮件的功能？"></a>01 <strong>你如何在 Spring Boot 项目中实现发送邮件的功能？</strong></h3><blockquote>
<p>“在 Spring Boot 项目中，我通过 Spring Email 技术实现了发送邮件的功能。首先，我导入了 <code>spring-boot-starter-mail</code> 依赖，然后在配置文件中设置了新浪邮箱的 SMTP 服务参数，包括主机名、端口、用户名、密码和协议，并启用了 SSL 安全连接。接着，我创建了一个 <code>MailClient</code> 工具类，封装了发送邮件的逻辑，使用 <code>JavaMailSender</code> 组件来发送邮件。对于 HTML 格式的邮件，我使用了 Thymeleaf 模板引擎，通过模板生成动态内容并发送。最后，我编写了测试类，验证了邮件发送功能是否正常工作。”</p>
</blockquote>
<h3 id="02-如何配置邮箱服务？"><a href="#02-如何配置邮箱服务？" class="headerlink" title="02 如何配置邮箱服务？"></a>02 如何配置邮箱服务？</h3><blockquote>
<p>选择了新浪邮箱作为邮件服务商，并在邮箱设置中开启了 SMTP 服务。在 Spring Boot 项目中，我通过配置文件设置了邮箱的 SMTP 参数，包括主机名（如 <code>smtp.sina.com</code>）、端口（如 465）、用户名、密码和协议（比如<code>spring.mail.protocol设置参数为smtps，spring.mail.properties.mail.smtp.ssl.enable=true</code>）。启用 SSL 是为了确保邮件发送的安全性，防止信息泄露。</p>
</blockquote>
<h3 id="03-你如何发送-HTML-格式的邮件？"><a href="#03-你如何发送-HTML-格式的邮件？" class="headerlink" title="03 你如何发送 HTML 格式的邮件？"></a>03 你如何发送 HTML 格式的邮件？</h3><blockquote>
<p>为了发送 HTML 格式的邮件，我使用了 Thymeleaf 模板引擎。首先，我创建了一个 HTML 模板文件，放置在 <code>templates/mail</code> 目录下。然后，我在代码中使用 <code>TemplateEngine</code> 处理模板，传入动态变量并生成最终的 HTML 内容。最后，我调用 <code>MailClient</code> 的 <code>send</code> 方法，将生成的 HTML 内容作为邮件正文发送。</p>
</blockquote>
<h2 id="二、注册功能"><a href="#二、注册功能" class="headerlink" title="二、注册功能"></a>二、注册功能</h2><h3 id="01-注册功能的开发流程吗？"><a href="#01-注册功能的开发流程吗？" class="headerlink" title="01 注册功能的开发流程吗？"></a>01 注册功能的开发流程吗？</h3><blockquote>
<ol>
<li><strong>访问注册页面</strong>：用户访问注册页面，前端通过简单的请求加载页面。我使用 <code>LoginController</code> 处理这个请求，返回注册页面的模板路径。</li>
<li><strong>提交注册数据</strong>：用户填写表单并提交，后端接收数据并进行验证。我在 <code>LoginController</code> 中定义了一个方法，处理提交的注册数据。</li>
<li><strong>数据验证</strong>：检查用户名、密码、邮箱是否为空，以及是否已存在。我使用了 <code>commons-lang</code> 工具包进行空值判断，并通过数据库查询验证用户名和邮箱的唯一性。</li>
<li><strong>生成激活信息</strong>：生成随机字符串作为激活码，并对密码进行 MD5 加密。我创建了一个 <code>Utils</code> 工具类，提供了生成随机字符串和 MD5 加密的方法。</li>
<li><strong>保存用户数据</strong>：将用户信息插入数据库，设置初始状态（如未激活）。我使用 MyBatis 将用户数据插入到 <code>user</code> 表中。</li>
<li><strong>发送激活邮件</strong>：使用 Thymeleaf 模板引擎生成 HTML 邮件，通过 Spring Email 技术发送激活链接。我创建了一个 <code>MailClient</code> 工具类，封装了邮件发送的逻辑。</li>
<li><strong>激活账号</strong>：用户点击激活链接后，后端验证激活码是否匹配。如果匹配，更新用户状态为已激活；如果不匹配，返回错误信息。我在 <code>LoginController</code> 中定义了一个方法，处理激活请求。</li>
</ol>
</blockquote>
<h3 id="02-数据验证与错误处理"><a href="#02-数据验证与错误处理" class="headerlink" title="02 数据验证与错误处理"></a>02 数据验证与错误处理</h3><blockquote>
<p>在注册功能中，我进行了以下数据验证和错误处理：</p>
<ol>
<li><strong>前端验证</strong>：使用 HTML5 的 <code>required</code> 属性和 JavaScript 进行初步验证，确保必填项不为空。</li>
<li><strong>后端验证</strong>：在业务层检查用户名、密码、邮箱是否为空，以及是否已存在。我使用了 <code>commons-lang</code> 工具包进行空值判断，并通过数据库查询验证用户名和邮箱的唯一性。</li>
<li><strong>错误处理</strong>：如果验证失败，返回错误信息，前端显示错误提示。例如，用户名已存在时，提示用户更换用户名。</li>
<li><strong>默认值保留</strong>：在错误页面中，保留用户已输入的值，提升用户体验。我通过 Thymeleaf 的 <code>th:value</code> 属性，将用户输入的值回显到表单中。</li>
</ol>
</blockquote>
<h3 id="03-邮件发送与激活功能如何实现的？"><a href="#03-邮件发送与激活功能如何实现的？" class="headerlink" title="03 邮件发送与激活功能如何实现的？"></a>03 邮件发送与激活功能如何实现的？</h3><blockquote>
<ol>
<li><strong>生成激活信息</strong>：在用户注册时，生成随机字符串作为激活码，并对密码进行 MD5 加密。我创建了一个 <code>Utils</code> 工具类，提供了生成随机字符串和 MD5 加密的方法。</li>
<li><strong>发送邮件</strong>：使用 Thymeleaf 模板引擎生成 HTML 邮件，包含激活链接。通过 Spring Email 技术发送邮件。我创建了一个 <code>MailClient</code> 工具类，封装了邮件发送的逻辑。</li>
<li><strong>激活账号</strong>：用户点击激活链接后，后端验证激活码是否匹配。如果匹配，更新用户状态为已激活；如果不匹配，返回错误信息。我在 <code>LoginController</code> 中定义了一个方法，处理激活请求。</li>
<li><strong>结果处理</strong>：根据激活结果，跳转到登录页面或首页(比如激活成功返回登录页面，要是重复激活或者激活失败返回到首页)，并显示相应的提示信息。</li>
</ol>
</blockquote>
<h3 id="04-如何使用模板引擎实现的代码复用？"><a href="#04-如何使用模板引擎实现的代码复用？" class="headerlink" title="04 如何使用模板引擎实现的代码复用？"></a>04 如何使用模板引擎实现的代码复用？</h3><blockquote>
<p>我使用 Thymeleaf 模板引擎实现页面复用：</p>
<ol>
<li><strong>代码复用</strong>：将公共部分（如页头、页脚）提取为单独的模板文件，通过 <code>th:replace</code> 属性在多个页面中复用。例如，我在 <code>header.html</code> 中定义了页头代码，并在注册页面和登录页面中复用。</li>
<li><strong>动态渲染</strong>：在模板中使用 Thymeleaf 的表达式和标签，动态渲染页面内容。例如，根据用户输入显示错误信息。</li>
<li><strong>路径管理</strong>：使用 <code>th:href</code> 和 <code>th:src</code> 标签管理静态资源的路径，确保页面代码整洁且易于维护。”</li>
</ol>
</blockquote>
<h2 id="三、-会话管理"><a href="#三、-会话管理" class="headerlink" title="三、 会话管理"></a>三、 会话管理</h2><h3 id="01-解释HTTP协议的无状态性，并说明为什么在Web开发中需要会话管理？"><a href="#01-解释HTTP协议的无状态性，并说明为什么在Web开发中需要会话管理？" class="headerlink" title="01 解释HTTP协议的无状态性，并说明为什么在Web开发中需要会话管理？"></a>01 解释HTTP协议的无状态性，并说明为什么在Web开发中需要会话管理？</h3><blockquote>
<p>HTTP协议是无状态的，这意味着同一个连接中的多次请求之间没有关联，服务器不会记住之前的请求。这种设计使得HTTP简单且可扩展，但在实际开发中，特别是需要用户登录和保持用户状态的场景下，无状态性就带来了问题。比如，用户登录后，服务器需要记住用户的身份，以便后续请求能够识别用户并提供个性化服务。为了解决这个问题，我们引入了会话管理技术，如Cookies和Session，通过它们来在多次请求之间保持用户的会话状态，从而实现业务连续性。</p>
</blockquote>
<h3 id="02-请解释Cookie和Session的区别，并说明它们各自的适用场景？"><a href="#02-请解释Cookie和Session的区别，并说明它们各自的适用场景？" class="headerlink" title="02 请解释Cookie和Session的区别，并说明它们各自的适用场景？"></a>02 请解释Cookie和Session的区别，并说明它们各自的适用场景？</h3><blockquote>
<p>Cookie和Session都是用于会话管理的技术，但它们的存储位置和使用场景有所不同。Cookie是存储在客户端（浏览器）的一小块数据，服务器通过响应头将Cookie发送给浏览器，浏览器在后续请求中自动携带这些数据。Cookie适合存储少量非敏感数据，比如用户的偏好设置或跟踪信息。Session则是存储在服务器端的数据，服务器通过一个唯一的Session ID来识别用户，Session ID通常通过Cookie传递给服务器。Session适合存储敏感或大量数据，比如用户的登录信息或购物车内容，因为数据存储在服务器端，安全性更高。</p>
</blockquote>
<h3 id="03-在分布式部署中，如何解决Session不共享的问题？"><a href="#03-在分布式部署中，如何解决Session不共享的问题？" class="headerlink" title="03 在分布式部署中，如何解决Session不共享的问题？"></a>03 在分布式部署中，如何解决Session不共享的问题？</h3><blockquote>
<p>在分布式部署中，用户的请求可能被分发到不同的服务器上，导致Session数据无法共享。为了解决这个问题，有几种常见的解决方案：</p>
<ol>
<li><strong>粘性Session</strong>：通过负载均衡器将同一个用户的请求始终分发到同一个服务器上，确保Session数据一致。</li>
<li><strong>同步Session</strong>：当一个服务器创建或更新Session时，将Session数据同步到其他服务器上。</li>
<li><strong>共享Session</strong>：使用一个独立的服务器（如Redis）来存储所有Session数据，其他服务器通过访问这个共享服务器来获取Session数据。</li>
<li><strong>数据库存储</strong>：将Session数据存储在数据库中，所有服务器都可以访问数据库来获取Session数据，实现数据共享。</li>
</ol>
</blockquote>
<h3 id="04-为什么在分布式系统中推荐使用Redis来存储Session数据？"><a href="#04-为什么在分布式系统中推荐使用Redis来存储Session数据？" class="headerlink" title="04 为什么在分布式系统中推荐使用Redis来存储Session数据？"></a>04 为什么在分布式系统中推荐使用Redis来存储Session数据？</h3><blockquote>
<p>在分布式系统中，Redis被广泛用于存储Session数据，主要因为它具有以下优点：</p>
<ol>
<li><strong>高性能</strong>：Redis是一个内存数据库，读写速度非常快，能够满足高并发的需求。</li>
<li><strong>数据共享</strong>：Redis可以作为所有服务器的共享存储，确保Session数据在不同服务器之间保持一致。</li>
<li><strong>持久化</strong>：Redis支持数据持久化，即使服务器重启，Session数据也不会丢失。</li>
<li><strong>灵活性</strong>：Redis支持多种数据结构，可以根据需求灵活存储和管理Session数据。</li>
</ol>
</blockquote>
<h3 id="05-在Java中，如何创建一个Session并存储用户数据？"><a href="#05-在Java中，如何创建一个Session并存储用户数据？" class="headerlink" title="05 在Java中，如何创建一个Session并存储用户数据？"></a>05 在Java中，如何创建一个Session并存储用户数据？</h3><blockquote>
<p>在Java中，创建Session并存储用户数据非常简单。首先，通过<code>HttpServletRequest</code>对象获取Session对象，如果Session不存在，服务器会自动创建一个新的Session。然后，可以通过<code>session.setAttribute(&quot;key&quot;, value)</code>方法将数据存储在Session中。l例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(); <span class="comment">// 获取或创建Session</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;JohnDoe&quot;</span>); <span class="comment">// 存储用户数据</span></span><br></pre></td></tr></table></figure>
<p>在后续的请求中，可以通过<code>session.getAttribute(&quot;key&quot;)</code>方法来读取存储的数据。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;username&quot;</span>); <span class="comment">// 读取用户数据</span></span><br></pre></td></tr></table></figure>
<p>这种方式使得在多次请求之间保持用户状态变得非常简单和高效。</p>
</blockquote>
<h2 id="四、验证码生成"><a href="#四、验证码生成" class="headerlink" title="四、验证码生成"></a>四、验证码生成</h2><h3 id="01-验证码功能实现介绍"><a href="#01-验证码功能实现介绍" class="headerlink" title="01 验证码功能实现介绍"></a>01 验证码功能实现介绍</h3><p>验证码生成是为了在登录页面中实现随机验证码功能，防止机器人暴力破解或恶意登录。通过要求用户输入验证码，可以有效区分人类用户和自动化程序，提升系统的安全性。课程推荐使用现成的工具<code>capture</code>，它能够快速生成验证码图片，并且配置灵活，适合在Web开发中使用。</p>
<hr>
<h3 id="02-capture工具介绍"><a href="#02-capture工具介绍" class="headerlink" title="02 capture工具介绍"></a>02 capture工具介绍</h3><p><code>capture</code>是一个用于在服务端内存中生成验证码的工具。它能够生成包含随机字符的图片，并且支持配置图片的宽度、高度、字符数量、字符范围、字体颜色、干扰线等参数，满足不同的需求。</p>
<h3 id="03-capture工具的使用步骤"><a href="#03-capture工具的使用步骤" class="headerlink" title="03 capture工具的使用步骤"></a>03 capture工具的使用步骤</h3><ol>
<li><p><strong>导入capture包</strong>：通过Maven依赖将<code>capture</code>工具导入到项目中，确保相关依赖下载完成。</p>
</li>
<li><p><strong>编写配置类</strong>：在Spring框架下，编写一个配置类，通过<code>@Configuration</code>注解标记为配置类，并通过<code>@Bean</code>注解将<code>capture</code>的核心对象<code>Producer</code>接口实例化并注入到Spring容器中。</p>
</li>
<li><p><strong>生成验证码</strong>：通过<code>Producer</code>接口的<code>createText</code>方法生成随机字符，并通过<code>createImage</code>方法根据字符生成验证码图片。</p>
<blockquote>
<p><code>Producer</code>接口有两个核心方法：</p>
<ul>
<li><code>createText</code>：生成随机的验证码字符。</li>
<li><code>createImage</code>：根据生成的字符创建验证码图片，图片可以配置尺寸、颜色、干扰线等参数。</li>
</ul>
</blockquote>
</li>
<li><p>生成的验证码字符需要存储在服务端的<code>Session</code>中，以便在用户提交表单时进行比对验证。<code>Session</code>是一种跨请求的存储机制，适合存储敏感信息，如验证码、用户登录状态等。</p>
</li>
<li><p>在登录页面中，验证码图片的访问路径指向一个动态生成验证码的接口（如<code>/capture</code>）。通过JavaScript实现验证码的刷新功能，用户点击刷新按钮时，调用<code>refreshCaptcha</code>方法重新加载验证码图片。</p>
</li>
<li><p>在Spring框架中，可以通过配置类将<code>capture</code>工具的核心对象<code>Producer</code>注入到Spring容器中。然后在Controller中编写接口，通过<code>Producer</code>生成验证码图片，并通过<code>HttpServletResponse</code>对象将图片输出到浏览器。</p>
</li>
</ol>
<h3 id="04-请解释验证码的作用以及为什么在登录页面中使用验证码？"><a href="#04-请解释验证码的作用以及为什么在登录页面中使用验证码？" class="headerlink" title="04 请解释验证码的作用以及为什么在登录页面中使用验证码？"></a>04 请解释验证码的作用以及为什么在登录页面中使用验证码？</h3><p><strong>答案：</strong><br>验证码的作用是区分人类用户和自动化程序，防止机器人暴力破解或恶意登录。在登录页面中使用验证码，可以增加攻击者的难度，确保只有真实用户才能完成登录操作，从而提升系统的安全性。</p>
<h3 id="05-请描述如何使用capture工具生成验证码，并说明其核心步骤。"><a href="#05-请描述如何使用capture工具生成验证码，并说明其核心步骤。" class="headerlink" title="05 请描述如何使用capture工具生成验证码，并说明其核心步骤。"></a>05 请描述如何使用<code>capture</code>工具生成验证码，并说明其核心步骤。</h3><p><strong>答案：</strong><br>使用<code>capture</code>工具生成验证码的核心步骤如下：</p>
<ol>
<li><strong>导入capture包</strong>：通过Maven依赖将<code>capture</code>工具导入到项目中。</li>
<li><strong>编写配置类</strong>：在Spring框架下，通过<code>@Configuration</code>和<code>@Bean</code>注解将<code>capture</code>的<code>Producer</code>接口实例化并注入到Spring容器中。</li>
<li><strong>生成验证码</strong>：通过<code>Producer</code>接口的<code>createText</code>方法生成随机字符，并通过<code>createImage</code>方法生成验证码图片，最后将图片输出到浏览器。</li>
</ol>
<hr>
<h3 id="06-在生成验证码时，如何确保验证码的字符能够被后续请求验证？"><a href="#06-在生成验证码时，如何确保验证码的字符能够被后续请求验证？" class="headerlink" title="06 在生成验证码时，如何确保验证码的字符能够被后续请求验证？"></a>06 在生成验证码时，如何确保验证码的字符能够被后续请求验证？</h3><p><strong>答案：</strong><br>生成的验证码字符需要存储在服务端的<code>Session</code>中。当用户提交表单时，服务器可以从<code>Session</code>中获取之前生成的验证码字符，与用户输入的验证码进行比对，从而完成验证。</p>
<hr>
<h3 id="07-在分布式系统中，如何确保验证码的字符能够在不同服务器之间共享？"><a href="#07-在分布式系统中，如何确保验证码的字符能够在不同服务器之间共享？" class="headerlink" title="07 在分布式系统中，如何确保验证码的字符能够在不同服务器之间共享？"></a>07 在分布式系统中，如何确保验证码的字符能够在不同服务器之间共享？</h3><p><strong>答案：</strong><br>在分布式系统中，可以通过将验证码字符存储在共享的数据库（如Redis）中，确保所有服务器都能访问到相同的验证码数据。这种方式解决了<code>Session</code>不共享的问题，同时保证了验证码的一致性。</p>
<hr>
<h3 id="08-如何实现验证码的动态刷新功能？"><a href="#08-如何实现验证码的动态刷新功能？" class="headerlink" title="08 如何实现验证码的动态刷新功能？"></a>08 如何实现验证码的动态刷新功能？</h3><p><strong>答案：</strong><br>通过JavaScript实现验证码的动态刷新功能。在登录页面中，为验证码图片设置一个动态的访问路径（如<code>/capture</code>），并通过JavaScript的<code>refreshCaptcha</code>方法重新加载验证码图片。每次点击刷新按钮时，调用该方法生成新的验证码并更新页面。</p>
<h2 id="五、登录，退出功能实现"><a href="#五、登录，退出功能实现" class="headerlink" title="五、登录，退出功能实现"></a>五、登录，退出功能实现</h2><h3 id="01-请描述登录功能的实现流程？"><a href="#01-请描述登录功能的实现流程？" class="headerlink" title="01 请描述登录功能的实现流程？"></a>01 请描述登录功能的实现流程？</h3><p><strong>答</strong>：<br>登录功能分为两个阶段：首次请求时返回登录页面，用户填写表单后提交二次请求。服务端首先校验验证码，从Session中取出生成的验证码与用户输入比对。验证码通过后，再检查用户是否存在、账号是否激活，最后对密码进行MD5加盐哈希，与数据库中存储的哈希值匹配。若全部通过，生成一个唯一UUID作为<code>tijcket</code>，记录到<code>login_ticket</code>表中，状态设为有效（<code>status=0</code>），并设置过期时间（例如12小时）。同时，将<code>ticket</code>通过Cookie下发到客户端，路径设置为根目录，后续请求自动携带该Cookie以维持登录状态。</p>
<hr>
<h3 id="02-为什么选择数据库存储登录凭证而不是Session？"><a href="#02-为什么选择数据库存储登录凭证而不是Session？" class="headerlink" title="02 为什么选择数据库存储登录凭证而不是Session？"></a>02 为什么选择数据库存储登录凭证而不是Session？</h3><p><strong>答</strong>：<br>Session在分布式场景中需要额外处理多节点同步问题（如Redis共享Session），而数据库存储<code>ticket</code>天然支持中心化查询，任何服务节点都可直接验证登录状态。此外，数据库允许精确控制凭证有效期（如“记住我”功能需长期凭证），而Session默认过期时间较为固定。从扩展性来看，未来若需改用Redis等高性能存储，只需调整数据访问层，业务逻辑无需改动。</p>
<hr>
<h3 id="03-数据库表login-ticket的设计思路是什么？"><a href="#03-数据库表login-ticket的设计思路是什么？" class="headerlink" title="03 数据库表login_ticket的设计思路是什么？"></a><strong>03 数据库表<code>login_ticket</code>的设计思路是什么？</strong></h3><p><strong>答</strong>：<br>该表包含五个核心字段：</p>
<ul>
<li><code>id</code>：自增主键，唯一标识每条凭证记录。</li>
<li><code>user_id</code>：外键关联用户表，指向所属用户。</li>
<li><code>ticket</code>：唯一字符串（UUID），用于客户端Cookie和服务端验证。</li>
<li><code>status</code>：标识凭证状态（0有效，1失效），避免物理删除，便于审计和排查问题。</li>
<li><code>expired</code>：TIMESTAMP类型，记录凭证过期时间，由服务端根据业务需求动态计算（如默认12小时或“记住我”的100天）。</li>
</ul>
<p>通过<code>status</code>和<code>expired</code>字段组合，可高效筛选有效凭证，避免全表扫描。</p>
<hr>
<h3 id="04-验证码的作用是什么？如何防止验证码被绕过？"><a href="#04-验证码的作用是什么？如何防止验证码被绕过？" class="headerlink" title="04 验证码的作用是什么？如何防止验证码被绕过？"></a>04 验证码的作用是什么？如何防止验证码被绕过？</h3><p><strong>答</strong>：<br>验证码主要用于防御暴力破解和机器自动登录。实现时，服务端生成验证码图片并将文本存入Session，用户提交登录请求后，立即从Session中移除验证码文本，确保单次有效性。此外，服务端会对登录接口进行限流，例如同一IP在1分钟内失败超过5次，则锁定该账号15分钟，并通过Redis记录失败次数，防止恶意尝试。</p>
<hr>
<h3 id="05-退出功能如何确保用户完全登出？"><a href="#05-退出功能如何确保用户完全登出？" class="headerlink" title="05 退出功能如何确保用户完全登出？"></a>05 退出功能如何确保用户完全登出？</h3><p><strong>答</strong>：<br>用户点击退出时，服务端执行两步操作：</p>
<ol>
<li><strong>失效凭证</strong>：根据Cookie中的<code>ticket</code>更新<code>login_ticket</code>表，将<code>status</code>设为1（失效）。</li>
<li><strong>清除Cookie</strong>：返回响应时设置同名Cookie，<code>Max-Age=0</code>，覆盖浏览器原有Cookie，触发客户端立即删除。<br>双管齐下确保服务端不再认可该凭证，且客户端无法再次携带它发起请求</li>
</ol>
<hr>
<h3 id="06-如果用户同时在多设备登录，系统如何处理？"><a href="#06-如果用户同时在多设备登录，系统如何处理？" class="headerlink" title="06. 如果用户同时在多设备登录，系统如何处理？"></a>06. 如果用户同时在多设备登录，系统如何处理？</h3><p><strong>答</strong>：<br>设计上允许同一用户生成多个有效<code>ticket</code>，每条记录对应不同设备。退出时仅失效当前设备的<code>ticket</code>，其他设备仍保持登录状态。若需强制所有设备下线，可在用户修改密码时批量将其所有<code>ticket</code>标记为失效。</p>
<hr>
<h3 id="07-MyBatis中注解和XML配置如何选择？"><a href="#07-MyBatis中注解和XML配置如何选择？" class="headerlink" title="07. MyBatis中注解和XML配置如何选择？"></a>07. MyBatis中注解和XML配置如何选择？</h3><p><strong>答</strong>：<br>注解适合简单SQL（如<code>@Select(&quot;SELECT * FROM user WHERE id=#&#123;id&#125;&quot;)</code>），开发效率高；XML则便于管理复杂SQL（如动态条件拼接、关联查询）。项目中<code>login_ticket</code>的增删改查使用注解实现，而用户分页查询等复杂逻辑通过XML配置，保持代码整洁性和可维护性。</p>
<h2 id="六、登录退出功能的实现"><a href="#六、登录退出功能的实现" class="headerlink" title="六、登录退出功能的实现"></a>六、登录退出功能的实现</h2><blockquote>
<p>Spring框架中如何通过拦截器（Interceptor）统一管理用户登录状态，并实现页面动态显示登录信息的功能。</p>
<p>每个页面的头部需要根据用户是否登录来展示不同内容（比如已登录显示头像，未登录显示注册入口）。为了避免在每个Controller重复编写登录校验代码，引入了拦截器。拦截器会在请求到达Controller前统一处理登录凭证（如从Cookie中提取ticket），验证用户身份，并将用户信息暂存到线程安全的存储中（如ThreadLocal），供后续流程使用，但是由于Web应用需要同时处理多个请求，每个请求对应独立线程。视频中通过<code>ThreadLocal</code>实现用户数据的线程隔离，确保不同请求间的用户信息互不干扰。例如，用户A的登录数据不会与用户B的数据冲突，即使两者同时发起请求。在请求处理完成后（Controller执行后），拦截器的<code>postHandle</code>方法会将用户信息添加到模型（Model）中，前端模板（如Thymeleaf）通过判断Model中的数据动态渲染页面。例如，如果用户已登录，模板会显示用户头像和昵称；未登录则展示登录按钮。</p>
</blockquote>
<p>应用了Spring Email和SpringMvc中的Interceptor（拦截器），其中拦截器能拦截所有请求，能解决通用的问题，涉及的面比较广、影响的请求比较多要重点关注。权限模块主要开发了注册、登录、退出、状态（在每个页面上怎么去显示登录用户的头像、用户名等）、设置（用户头像、修改密码等）、授权（不同类型的用户访问不同的功能，使用Security实现的）、会话管理（重点需要了解Cookie、session、项目中为什么不用session(主要是考虑分布式部署Session的问题)、不用session是如何解决的问题（把数据存在Redis中，使用了ThreadLocal））等功能。</p>
<h3 id="01-请说明如何利用拦截器实现登录信息的统一处理？"><a href="#01-请说明如何利用拦截器实现登录信息的统一处理？" class="headerlink" title="01 请说明如何利用拦截器实现登录信息的统一处理？"></a>01 请说明如何利用拦截器实现登录信息的统一处理？</h3><p><strong>答</strong>：<br>在项目中，我通过Spring拦截器统一处理登录状态，避免在每个Controller重复校验用户。具体来说，拦截器会在每个请求开始时，从Cookie中提取登录凭证（ticket），然后查询数据库验证凭证是否有效。如果有效，就将用户信息存储到当前线程的独立变量中（比如用ThreadLocal），这样后续业务逻辑可以直接获取用户数据。最后在请求结束时清理这些数据，确保线程安全。整个过程对业务代码无侵入，且集中管理登录状态，减少了代码冗余。</p>
<hr>
<h3 id="02-为什么选择ThreadLocal存储用户数据？如何避免内存泄漏？"><a href="#02-为什么选择ThreadLocal存储用户数据？如何避免内存泄漏？" class="headerlink" title="02 为什么选择ThreadLocal存储用户数据？如何避免内存泄漏？"></a>02 为什么选择ThreadLocal存储用户数据？如何避免内存泄漏？</h3><p><strong>答</strong>：<br>因为每个请求对应一个独立线程，ThreadLocal可以为每个线程创建用户数据的副本，不同线程之间互不干扰，天然支持高并发场景。例如，用户A和用户B同时登录，他们的数据会分别存在各自的线程中，不会互相覆盖。<br>为了避免内存泄漏，我们会在请求处理完成后主动清理ThreadLocal中的数据。通常是在拦截器的最终阶段（如afterCompletion方法）调用remove()方法，确保线程池复用时不会残留旧数据。</p>
<hr>
<h3 id="03-拦截器的三个核心方法分别是什么？它们的执行顺序是怎样的？"><a href="#03-拦截器的三个核心方法分别是什么？它们的执行顺序是怎样的？" class="headerlink" title="03 拦截器的三个核心方法分别是什么？它们的执行顺序是怎样的？"></a>03 拦截器的三个核心方法分别是什么？它们的执行顺序是怎样的？</h3><p><strong>答</strong>：<br>拦截器的三个方法是：</p>
<ol>
<li><strong>preHandle</strong>：在Controller处理请求前执行，比如这里我们用它校验用户登录状态。</li>
<li><strong>postHandle</strong>：在Controller处理完请求后、返回视图前执行，此时我们可以将用户数据添加到模型（Model）中，供前端页面展示。</li>
<li><strong>afterCompletion</strong>：在整个请求完成（包括视图渲染）后执行，用于资源清理，比如移除ThreadLocal中的数据。<br>它们的执行顺序是：preHandle → Controller → postHandle → 视图渲染 → afterCompletion。</li>
</ol>
<hr>
<h3 id="04-如果拦截器误拦截了静态资源（如CSS、JS文件），如何解决？"><a href="#04-如果拦截器误拦截了静态资源（如CSS、JS文件），如何解决？" class="headerlink" title="04 如果拦截器误拦截了静态资源（如CSS、JS文件），如何解决？"></a>04 如果拦截器误拦截了静态资源（如CSS、JS文件），如何解决？</h3><p><strong>答</strong>：<br>在配置拦截器时，可以通过排除路径（excludePathPatterns）指定不拦截的静态资源。例如，将<code>/*.css</code>、<code>/*.js</code>添加到排除列表中，这样拦截器会跳过对这些路径的处理。这样做既能保证业务请求被拦截处理，又避免影响静态资源的正常加载。</p>
<hr>
<h3 id="05-用户未登录和已登录时，页面头部如何动态显示不同内容？"><a href="#05-用户未登录和已登录时，页面头部如何动态显示不同内容？" class="headerlink" title="05 用户未登录和已登录时，页面头部如何动态显示不同内容？"></a><strong>05 用户未登录和已登录时，页面头部如何动态显示不同内容？</strong></h3><p><strong>答</strong>：<br>在拦截器中，我们会将用户信息存入Model，前端页面（如Thymeleaf或Freemarker）根据Model中是否有用户数据做条件判断。如果用户已登录，页面渲染时显示头像、用户名等；如果未登录，则展示登录和注册链接。这种逻辑完全由模板引擎处理，后端只需提供数据，实现了前后端解耦。</p>
<hr>
<h3 id="06-如何确保用户凭证（ticket）的安全性？"><a href="#06-如何确保用户凭证（ticket）的安全性？" class="headerlink" title="06 如何确保用户凭证（ticket）的安全性？"></a>06 如何确保用户凭证（ticket）的安全性？</h3><p><strong>答</strong>：<br>首先，凭证（ticket）本身是随机生成的唯一字符串，难以伪造。其次，我们通过Cookie下发凭证时会设置HttpOnly属性，防止JavaScript恶意窃取。同时，服务端每次收到请求都会校验ticket的有效性，包括检查状态是否失效、是否过期。即使凭证被截获，攻击者也无法在过期后使用，且服务端可以主动使token失效（如用户主动退出时）。</p>
<h2 id="七、头像上传功能如何实现的"><a href="#七、头像上传功能如何实现的" class="headerlink" title="七、头像上传功能如何实现的"></a>七、头像上传功能如何实现的</h2><p><strong>面试官</strong>：能说一下如何实现头像上传功能吗？</p>
<p><strong>我</strong>：好的，头像上传功能主要分为前端和后端两部分实现。</p>
<p>首先，<strong>前端</strong>会设计一个表单，设置 <code>enctype=&quot;multipart/form-data&quot;</code>，确保可以上传文件。用户通过 <code>&lt;input type=&quot;file&quot;&gt;</code> 选择图片后，可以用 <code>FileReader</code> 实现图片预览，提升用户体验。然后通过 <code>AJAX</code> 或 <code>Fetch API</code> 将文件异步上传到服务器，避免页面刷新。</p>
<p><strong>后端</strong>部分，我会用 <code>MultipartFile</code>（如果是 Spring Boot）接收上传的文件。文件存储有两种方式：一是保存到服务器的指定目录，生成唯一的文件名（比如 UUID + 时间戳）避免冲突；二是上传到云存储（如 AWS S3 或阿里云 OSS），提高文件的可靠性和访问效率。文件存储成功后，我会把路径保存到用户表的 <code>avatar</code> 字段中，方便后续展示。</p>
<p>在前端展示时，通过 <code>&lt;img&gt;</code> 标签加载用户头像，<code>src</code> 属性指向后端返回的路径或 URL。如果用户没上传头像，就显示默认头像。</p>
<p>此外，我会做一些优化，比如限制文件大小和格式，防止恶意文件上传；如果项目需要，还可以加入图片裁剪功能，确保头像显示比例一致。</p>
<p>总的来说，通过前后端配合，头像上传功能可以高效实现，同时兼顾用户体验和安全性。</p>
<h2 id="八、登录状态检查"><a href="#八、登录状态检查" class="headerlink" title="八、登录状态检查"></a>八、登录状态检查</h2><p>在面试中，你可以这样回答关于如何实现检查登录状态的问题：</p>
<hr>
<h3 id="01-你能解释一下如何实现检查登录状态的功能吗？"><a href="#01-你能解释一下如何实现检查登录状态的功能吗？" class="headerlink" title="01 你能解释一下如何实现检查登录状态的功能吗？"></a>01 你能解释一下如何实现检查登录状态的功能吗？</h3><p><strong>你</strong>：当然可以。实现检查登录状态的功能主要是为了确保用户在访问某些敏感或需要权限的功能时，必须处于登录状态。我们通过以下几个步骤来实现这一功能：</p>
<ol>
<li><p><strong>自定义注解</strong>：<br>• 首先，我们定义了一个自定义注解 <code>@LoginRequired</code>，用于标记那些需要登录才能访问的方法。这个注解通过 <code>@Target(ElementType.METHOD)</code> 指定它只能用在方法上，并通过 <code>@Retention(RetentionPolicy.RUNTIME)</code> 确保它在运行时有效。</p>
</li>
<li><p><strong>拦截器</strong>：<br>• 我们实现了一个拦截器 <code>LoginRequiredInterceptor</code>，它实现了 <code>HandlerInterceptor</code> 接口。在 <code>preHandle</code> 方法中，我们检查当前请求的目标方法是否带有 <code>@LoginRequired</code> 注解。<br>• 如果方法带有该注解，我们进一步检查用户是否已经登录。我们通过 <code>Holder</code> 类（通常是一个单例或上下文对象）来获取当前用户信息。如果用户未登录（即 <code>Holder.getUser() == null</code>），我们拒绝该请求，并通过 <code>response.sendRedirect</code> 将用户重定向到登录页面。</p>
</li>
<li><p><strong>注解应用</strong>：<br>• 在需要登录才能访问的方法上，我们添加 <code>@LoginRequired</code> 注解。例如，用户设置和上传头像的方法都需要登录才能访问，因此我们在这些方法上添加了该注解。</p>
</li>
<li><p><strong>拦截器配置</strong>：<br>• 最后，我们将拦截器配置到 Spring MVC 的拦截器链中，确保它能够拦截所有请求，并根据注解进行相应的处理。</p>
</li>
</ol>
<p>通过这种方式，我们确保了只有登录的用户才能访问特定的功能，从而提高了系统的安全性。</p>
<h3 id="02-你能详细解释一下拦截器是如何工作的吗？"><a href="#02-你能详细解释一下拦截器是如何工作的吗？" class="headerlink" title="02 你能详细解释一下拦截器是如何工作的吗？"></a>02 你能详细解释一下拦截器是如何工作的吗？</h3><p><strong>你</strong>：当然可以。拦截器是 Spring MVC 提供的一种机制，允许我们在请求处理的不同阶段插入自定义逻辑。具体来说，<code>LoginRequiredInterceptor</code> 的工作流程如下：</p>
<ol>
<li><p><strong>preHandle</strong>：<br>• 在请求到达控制器之前，<code>preHandle</code> 方法会被调用。我们在这个方法中检查请求的目标方法是否带有 <code>@LoginRequired</code> 注解。<br>• 如果方法带有该注解，我们进一步检查用户是否已经登录。如果用户未登录，我们返回 <code>false</code>，并重定向用户到登录页面，阻止请求继续处理。</p>
</li>
<li><p><strong>postHandle</strong>：<br>• 在控制器处理完请求之后，视图渲染之前，<code>postHandle</code> 方法会被调用。我们在这个方法中可以进行一些后处理操作，但在这个场景中我们不需要使用它。</p>
</li>
<li><p><strong>afterCompletion</strong>：<br>• 在请求处理完成之后，无论成功与否，<code>afterCompletion</code> 方法都会被调用。我们在这个方法中可以进行一些清理操作，但在这个场景中我们也不需要使用它。</p>
</li>
</ol>
<p>通过这种方式，拦截器能够在请求处理的不同阶段插入自定义逻辑，确保只有登录的用户才能访问特定的功能。</p>
<h3 id="03-你提到使用自定义注解，你能解释一下如何定义和使用它吗？"><a href="#03-你提到使用自定义注解，你能解释一下如何定义和使用它吗？" class="headerlink" title="03 你提到使用自定义注解，你能解释一下如何定义和使用它吗？"></a>03 你提到使用自定义注解，你能解释一下如何定义和使用它吗？</h3><p><strong>你</strong>：当然可以。自定义注解 <code>@LoginRequired</code> 的定义和使用如下：</p>
<ol>
<li><p><strong>定义注解</strong>：<br>• 我们使用 <code>@Target(ElementType.METHOD)</code> 指定该注解只能用在方法上。<br>• 使用 <code>@Retention(RetentionPolicy.RUNTIME)</code> 确保该注解在运行时有效，这样我们才能在运行时通过反射读取它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LoginRequired &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用注解</strong>：<br>• 在需要登录才能访问的方法上，我们添加 <code>@LoginRequired</code> 注解。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LoginRequired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userSetting</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 用户设置逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>读取注解</strong>：<br>• 在拦截器中，我们通过反射读取方法上的 <code>@LoginRequired</code> 注解。如果方法带有该注解，我们进一步检查用户是否已经登录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LoginRequired</span> <span class="variable">loginRequired</span> <span class="operator">=</span> method.getAnnotation(LoginRequired.class);</span><br><span class="line"><span class="keyword">if</span> (loginRequired != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查用户是否登录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>通过这种方式，我们能够灵活地标记哪些方法需要登录才能访问，并在拦截器中统一处理这些方法的访问控制。</p>
<h2 id="九、敏感词过滤"><a href="#九、敏感词过滤" class="headerlink" title="九、敏感词过滤"></a>九、敏感词过滤</h2><h3 id="01-如何实现的敏感词过滤功能"><a href="#01-如何实现的敏感词过滤功能" class="headerlink" title="01 如何实现的敏感词过滤功能"></a>01 如何实现的敏感词过滤功能</h3><p><strong>回答</strong>：<br>在实现敏感词过滤功能时，我使用了<strong>前缀树（Trie树）​</strong>数据结构来高效地存储和检索敏感词。具体步骤如下：</p>
<ol>
<li><strong>定义前缀树</strong>：我定义了一个前缀树结构，每个节点包含一个字符和一个标记，用于表示该节点是否是一个敏感词的结尾。</li>
<li><strong>初始化前缀树</strong>：我从配置文件中读取敏感词列表，并将这些敏感词逐个插入到前缀树中。每个敏感词的字符会被逐层插入到树中，形成树的分支。</li>
<li><strong>敏感词过滤算法</strong>：我使用了三个指针来遍历用户输入的字符串。指针一指向前缀树的当前节点，指针二指向字符串的起始位置，指针三指向字符串的当前位置。通过遍历字符串，逐个字符在前缀树中查找匹配。如果找到匹配的字符，则继续向下查找；如果未找到匹配，则跳过该字符。当检测到一个完整的敏感词时，将其替换为预定义的符号（如“<em>*</em>”），并继续遍历剩余的字符串。</li>
<li><strong>处理特殊符号</strong>：为了防止用户在敏感词中插入特殊符号（如“开*票”）来绕过过滤，算法会跳过这些特殊符号，继续检测后续字符。</li>
</ol>
<p>通过这种方式，我实现了一个高效且可靠的敏感词过滤功能，能够有效地检测并替换用户输入中的敏感词汇。</p>
<h3 id="02-视频功能实现的功能"><a href="#02-视频功能实现的功能" class="headerlink" title="02 视频功能实现的功能"></a>02 视频功能实现的功能</h3><p>在视频中，主要讲解的是如何实现一个<strong>敏感词过滤</strong>的功能。这个功能的核心目的是在用户输入的内容中检测并替换掉敏感词汇，以确保内容的合法性和安全性。具体实现步骤如下：</p>
<ol>
<li><strong>定义前缀树（Trie树）数据结构</strong>：<ul>
<li>前缀树是一种树形数据结构，用于高效地存储和检索字符串。每个节点代表一个字符，从根节点到某个节点的路径表示一个字符串。</li>
<li>在前缀树中，根节点不包含任何字符，其他每个节点包含一个字符。通过从根节点到某个节点的路径，可以拼接出一个完整的字符串。</li>
</ul>
</li>
<li><strong>初始化前缀树</strong>：<ul>
<li>从配置文件中读取敏感词列表，并将这些敏感词逐个插入到前缀树中。每个敏感词的字符会被逐层插入到树中，形成树的分支。</li>
<li>在插入过程中，如果某个字符已经存在于树中，则直接复用该节点，避免重复创建。</li>
</ul>
</li>
<li><strong>敏感词过滤算法</strong>：<ul>
<li>使用三个指针来遍历用户输入的字符串：<ul>
<li><strong>指针一</strong>：指向前缀树的当前节点，用于在树中查找匹配的字符。</li>
<li><strong>指针二</strong>：指向字符串的起始位置，用于标记疑似敏感词的开始。</li>
<li><strong>指针三</strong>：指向字符串的当前位置，用于遍历字符串。</li>
</ul>
</li>
<li>算法通过遍历字符串，逐个字符在前缀树中查找匹配。如果找到匹配的字符，则继续向下查找；如果未找到匹配，则跳过该字符。</li>
<li>当检测到一个完整的敏感词时，将其替换为预定义的符号（如“<em>*</em>”），并继续遍历剩余的字符串。</li>
</ul>
</li>
<li><strong>处理特殊符号</strong>：<ul>
<li>为了防止用户在敏感词中插入特殊符号（如“开*票”）来绕过过滤，算法会跳过这些特殊符号，继续检测后续字符。</li>
</ul>
</li>
</ol>
<h2 id="十、-发布帖子"><a href="#十、-发布帖子" class="headerlink" title="十、 发布帖子"></a>十、 发布帖子</h2><h3 id="01-如何实现的发布帖子？"><a href="#01-如何实现的发布帖子？" class="headerlink" title="01 如何实现的发布帖子？"></a>01 如何实现的发布帖子？</h3><h3 id="面试回答话术"><a href="#面试回答话术" class="headerlink" title="面试回答话术"></a><strong>面试回答话术</strong></h3><p>发布帖子是简单的增删改，调用底层mapper来添加帖子，只需要判断当前用户是否登录，index页面也会做判断，当前没有用户登录时，不会显示发布新帖按钮</p>
<p>“在实现发布帖子功能时，我主要分为前端页面设计、异步请求发送、后端数据处理和数据库操作四个部分来实现。下面我详细说明一下：</p>
<ol>
<li><strong>前端页面设计</strong>：<ul>
<li>我在首页设计了一个‘我要发布’按钮，点击后会弹出一个模态框。模态框中包含两个输入框，分别用于输入帖子标题和内容。底部有一个‘发布’按钮，点击后触发异步请求。</li>
</ul>
</li>
<li><strong>异步请求发送</strong>：<ul>
<li>使用 jQuery 的 <code>$.post()</code> 方法发送异步请求。请求的 URL 是 <code>/community/discuss/add</code>，请求参数是用户输入的标题和内容，格式为 JSON 对象。在回调函数中，我处理服务器返回的 JSON 数据，并根据返回的 <code>code</code> 值动态提示用户发布结果。</li>
</ul>
</li>
<li><strong>后端数据处理</strong>：<ul>
<li>后端使用 Spring Boot 框架处理请求。在 <code>DiscussPostController</code> 中，我定义了一个 <code>addDiscussPost</code> 方法，使用 <code>@PostMapping</code> 注解标记为 POST 请求，并通过 <code>@ResponseBody</code> 返回 JSON 格式数据。</li>
<li>首先，我验证用户是否登录。如果未登录，返回 403 状态码和提示信息。如果已登录，构造 <code>DiscussPost</code> 对象，设置标题、内容、用户 ID 和创建时间等字段，然后调用 <code>DiscussPostService</code> 的 <code>addDiscussPost</code> 方法保存帖子。</li>
<li>在 <code>DiscussPostService</code> 中，我对标题和内容进行了敏感词过滤（使用 <code>SensitiveFilter</code>）和 HTML 标签转义（使用 <code>HtmlUtils.escape</code>），确保数据的安全性和合规性。</li>
</ul>
</li>
<li><strong>数据库操作</strong>：<ul>
<li>在 <code>DiscussPostMapper</code> 中，我定义了 <code>insertDiscussPost</code> 方法，使用 MyBatis 的 <code>@Insert</code> 注解编写 SQL 语句，将帖子数据插入 <code>discuss_post</code> 表。</li>
</ul>
</li>
<li><strong>前端处理返回结果</strong>：<ul>
<li>在异步请求的回调函数中，我解析服务器返回的 JSON 数据。如果 <code>code</code> 为 0，提示用户发布成功并刷新页面；如果 <code>code</code> 为 403，提示用户未登录；其他情况则提示发布失败的具体原因。</li>
</ul>
</li>
</ol>
<h2 id="十一、帖子详情、显示评论"><a href="#十一、帖子详情、显示评论" class="headerlink" title="十一、帖子详情、显示评论"></a>十一、帖子详情、显示评论</h2><h3 id="01-请描述一下你实现的“帖子详情”功能。"><a href="#01-请描述一下你实现的“帖子详情”功能。" class="headerlink" title="01 请描述一下你实现的“帖子详情”功能。"></a><strong>01 请描述一下你实现的“帖子详情”功能。</strong></h3><p><strong>我的回答：</strong></p>
<p>“帖子详情”功能是用户在浏览帖子列表时，点击某个帖子的标题后，能够跳转到一个展示该帖子详细信息的页面。这个页面上会完整展示帖子的标题、作者、发布时间、正文等内容。</p>
<p>在实现这个功能时，我按照以下步骤进行开发：</p>
<ol>
<li><strong>数据访问层</strong>：<ul>
<li>在<code>Mapper</code>接口中增加了一个根据帖子ID查询帖子详情的方法<code>selectDiscussPostById</code>，并在对应的<code>XML</code>配置文件中编写了SQL查询语句，通过<code>WHERE id = #&#123;id&#125;</code>条件来获取指定帖子的详细信息。</li>
</ul>
</li>
<li><strong>业务逻辑层</strong>：<ul>
<li>在<code>Service</code>层中，我增加了一个<code>findDiscussPostById</code>方法，直接调用<code>Mapper</code>层的方法来获取帖子数据。由于这里没有复杂的业务逻辑，所以实现起来比较简单。</li>
</ul>
</li>
<li><strong>表现层</strong>：<ul>
<li>在<code>Controller</code>层中，我增加了一个处理帖子详情请求的方法<code>getDiscussPost</code>，通过<code>@RequestMapping</code>注解定义了访问路径，并使用<code>@PathVariable</code>注解获取帖子ID。然后调用<code>Service</code>层的方法查询帖子数据，并将结果通过<code>Model</code>对象传递给前端页面。</li>
<li>为了在页面上展示作者信息，我还通过<code>UserService</code>查询了帖子的作者信息，并将作者数据一并传递给前端。</li>
</ul>
</li>
<li><strong>前端页面</strong>：<ul>
<li>在帖子列表页面上，我为每个帖子的标题添加了一个超链接，点击后会跳转到帖子详情页。链接的路径通过<code>Thymeleaf</code>模板引擎动态生成，确保能够正确传递帖子ID。</li>
<li>在帖子详情页面上，我使用<code>Thymeleaf</code>的<code>th:text</code>和<code>th:src</code>等标签动态渲染帖子的标题、作者头像、用户名、发布时间、正文等内容。</li>
</ul>
</li>
<li><strong>优化与扩展</strong>：<ul>
<li>考虑到性能问题，我计划在后续引入<code>Redis</code>缓存，将频繁访问的帖子数据和用户信息缓存起来，减少数据库查询的开销。</li>
<li>目前帖子详情页还没有展示回复功能，后续会结合“帖子回复”模块的开发，进一步完善帖子详情页的功能。</li>
</ul>
</li>
</ol>
<blockquote>
<p>帖子详情是指点击首页的贴名后会跳转到该帖子的详情页，详情页会显示帖子内容，以及该帖子的评论和回复，当点击贴名发送请求时，会把所点击的帖子id传到controller中，随后调用mapper找出该帖子，传回到controller中，设置分页信息，根据帖子id查询评论列表，由于在页面中要显示该评论的作者，以及该评论和回复的各种信息，因此遍历评论列表，通过每条评论的id查询每条评论下是否有回复列表，添加帖子中controller传回页面携带的数据中除了基本的帖子信息，也有一个List，{comments}，是Map<String，Object>类型，存放的是评论列表，每条记录中map里存放的是该评论的内容，作者等信息，还有回复列表，回复列表结构和评论列表一样，是list，类型为Map<String，Object>,每条map存放的是回复的相关信息。回复列表比评论列表多一个参数:目标对象，指的是当前回复回复的对象是谁。</p>
</blockquote>
<h2 id="十二、添加评论"><a href="#十二、添加评论" class="headerlink" title="十二、添加评论"></a>十二、添加评论</h2><p>添加评论比较重要的一点是确定好targetId目标对象id以及entityType，评论类型。如果评论是回复人的，需要设置targetId，不过targetId是当用户输入完回复信息后发送请求时直接封装到comment对象中，对象中也封装有entityType评论类型，entityId评论id。</p>
<h2 id="十三、私信列表和私信详情"><a href="#十三、私信列表和私信详情" class="headerlink" title="十三、私信列表和私信详情"></a>十三、私信列表和私信详情</h2><h3 id="1-私信列表"><a href="#1-私信列表" class="headerlink" title="1.私信列表"></a>1.私信列表</h3><p>私信列表是指打开首页并登录后显示的消息，在消息页面中，显示的是消息列表，需要查询数据库中的消息列表，并且需要显示当前用户的所有未读消息数。点开消息后，出现的是当前用户与目标用户以往发送的私信，并且当用户有未读消息时，需要提示当前未读消息数，当用户打开后未读消息数清0。</p>
<p>私信列表就是简单的调用底层mapper，查询属于该用户的私信时做判断，fromId==userId || toId == userId,并且查询私信列表时，只需要查询该用户根据conversation_id分组后最新的一条数据，具体的私信内容在在点开私信详情后在显示。在查询私信列表时并将该用户每条私信列表的未读数量和私信数量传入前台页面。</p>
<h3 id="2-私信详情"><a href="#2-私信详情" class="headerlink" title="2.私信详情"></a>2.私信详情</h3><p>私信详情就是点开某条具体的私信后显示当前用户和目标对象所进行的所有私信记录，查询出当前conversationId所有私信信息后，为每条消息设置信息，fromUser，主要作用是显示发送该消息的用户的头像。</p>
<h2 id="十四、项目中的redis如何使用的？"><a href="#十四、项目中的redis如何使用的？" class="headerlink" title="十四、项目中的redis如何使用的？"></a>十四、项目中的redis如何使用的？</h2><h3 id="01-使用场景"><a href="#01-使用场景" class="headerlink" title="01 使用场景"></a>01 使用场景</h3><p><strong>缓存点赞和关注：</strong></p>
<p>在项目中，点赞是非常频繁的操作，如果将点赞的信息存入到数据库中，在用户量不高或者低并发的情况下，不会有情况，但如果用户多或者操作非常频繁时就会大大增大系统的压力，因此需要将点赞信息存入redis中，在nosql中存取数据比在关系型数据库中存取数据快的多。</p>
<blockquote>
<p>1.<strong>点赞</strong></p>
<p>编写likeService，点赞的逻辑是当用户点赞后，首先通过entityType，entityId，userId获取entityLikeKey和userLikeKey。entityLikeKey存放的是为该实体点赞的用户，userLikeKey存放的是该userId所获得的所有赞个数。当有用户为帖子或者评论点赞时，将entityType，entityId，userId传到controller层执行点赞操作，首先判断该用户是否为这个实体点过赞，如果之前点过，这次操作应该是取消点赞，同时将实体所属用户所获得的赞减一。如果没点过赞，将userId存到实体所获赞的set集合中，并将实体所属用户所获得的赞加一。这里entityuserId是指实体所属用户id，userId是当前登录的用户</p>
<p><strong>2.缓存实体赞</strong></p>
<p>在页面显示时，也要显示当前实体所获得的赞。并且每当当前用户打开帖子时，都要判断当前用户对这个帖子以及对所有评论的点赞状态，只需要查询实体点赞列表中是否存在当前用户id即可。（如何实现见03）</p>
<p><strong>3.我收到的赞</strong></p>
<p>我收到的赞用于打开个人主页后需要在页面显示该用户所有的赞，因为在点赞中已经设置点赞后将用户赞加一，所有只需要调用方法查询该用户key下的数值是多少就行。</p>
</blockquote>
<p> 1）Redis缓存用户点赞数用String类型，以用户ID为key，点赞时，自增，取消赞时，自减；缓存实体点赞数，set类型，用户给实体点赞时添加进列表，取消赞时则移除，最后用size统计；</p>
<p>​    2）缓存粉丝列表，使用zset，存入粉丝的id和关注的时间戳，使用zCard获得粉丝数量。利用reverseRange的时间戳反向排序，按关注时间加载粉丝列表。</p>
<p><strong>优化登录：</strong></p>
<p> 1）使用Redis缓存用户信息。将user缓存到Redis中，获取user时，先从Redis获取。取不到时，则从数据库中查询，再缓存到Redis中。因为很多界面都要用到user信息，并发时，频繁的访问数据库，会导致数据库崩溃。变更数据库时，先更新数据库，再清空缓存；</p>
<p>2）使用Redis缓存验证码 。原本添加到session中，减轻服务器压力。将验证码存到Redis中，方便查询检验；</p>
<ul>
<li>-验证码需要频繁的访问与刷新，对性能要求很高；</li>
<li><p>-验证码不需要永久存储，通常在很短的时间内就会失效；</p>
</li>
<li><p>-分布式部署时，存在session共享问题；</p>
</li>
</ul>
<p>3）登录凭证：原本添加到MySQL中，为减轻每次登录都去查询数据库的压力，将登录凭证ticket缓存在Redis中，防止每次都要进行数据库的查询，提高并发能力。退出登录时，原本要修改数据库中的登录凭证，现在只需要修改Redis即可。</p>
<p><strong>关注：</strong></p>
<p>实现关注功能时，我使用 Redis 来存储关注关系，设计了两类 Key：<code>following:userId:entityType</code> 存储用户关注的实体，<code>follower:entityType:entityId</code> 存储实体的粉丝。通过 Redis 的 ZSet 存储数据，Score 为时间戳，方便按时间排序。关注操作时，将实体 ID 添加到用户的关注目标 Key，同时将用户 ID 添加到实体的粉丝 Key，并使用 Redis 的事务确保数据一致性；取消关注时则移除相应数据。这种设计高效、可靠，支持多种实体类型，并且通过 Redis 的事务机制保证了操作的原子性。</p>
<h4 id="统计统计网站UA和DAU"><a href="#统计统计网站UA和DAU" class="headerlink" title="统计统计网站UA和DAU"></a><strong>统计统计网站UA和DAU</strong></h4><p>（见下面）</p>
<blockquote>
<p>使用Redis的高级数据结构：<br>HyperLogLog：超级日志，统计独立整数个数。统计UA（独立访问）时，以日期为 rediskey ，将客户端IP add 到HyperLogLog中（redisTemplate.opsForHyperLogLog().add(redisKey, i);）<br>Bitmap：位图，比如365天的签到，只需要３６５／８个字节的大小。统计DAU（日活跃用户）时，以日期为 rediskey ，以用户ID作为位（在数据中的位置），用 or 操作，既可以方便的统计一段时间内的注册用户访问人数。</p>
</blockquote>
<h3 id="02-redis的key怎么设计（怎样存储的点赞、关注、缓存用户数据）？"><a href="#02-redis的key怎么设计（怎样存储的点赞、关注、缓存用户数据）？" class="headerlink" title="02 redis的key怎么设计（怎样存储的点赞、关注、缓存用户数据）？"></a>02 redis的key怎么设计（怎样存储的点赞、关注、缓存用户数据）？</h3><p>redis的key是String类型的，编写了一个工具类来生成redis的key。key由多个单词拼接而成，中间采用冒号隔开，有的单词是固定的，有些单词是动态的。</p>
<p>点赞使用set类型存储，key为点赞对象，set中保存点赞人的ID<br>关注使用zSet类型存储，key为被关注者，set保存关注者以及关注时间为score<br>缓存用户数据使用Value类型，key为用userID得到的key，value为user对象（设置过期时间，且数据修改时需要清除缓存）</p>
<p> 验证码是与user相关的，但是这里我们不能直接传入userId,因为还未登录，我们不知道用户是谁。这里传入了一个字符串owner，这是在用户访问登录页面的时候，给他发一个凭证（随机字符串），存到cookie里，用的时候从cookie内将这个owner取出来，在得到rediskey，然后获取验证码，与输入的验证码进行对比。</p>
<h3 id="03-缓存点赞数如何实现"><a href="#03-缓存点赞数如何实现" class="headerlink" title="03 缓存点赞数如何实现"></a>03 缓存点赞数如何实现</h3><p>帖子和评论的赞一起存，统称为实体的赞。还需要统计用户的赞（用户的帖子和评论收到的赞的总和）。因为如果统计用户所有帖子和评论的赞得到用户获得的赞太麻烦，所以这里以用户ID采用rediskey工具拼接为key记录点赞数量（这就会涉及到事务操作。用户的帖子或者评论的点赞数增加了对应的用户的赞要增加）。</p>
<p>具体实现：使用redis来存储点赞数，首先需要构造redis的key，</p>
<p>点赞使用set类型存储，key为点赞对象，set中保存点赞人的ID</p>
<p>点赞的时候需要判断用户是否已经点赞：通过redistemplate.opsforSet().ismember方法 如果已经点过赞了就要把点赞记录删除 否则添加数据。 这里用到了事务操作 重写了execute方法</p>
<p>项目中的redis在存储用户信息时，是只读模式。</p>
<h3 id="04-如何解决缓存和数据库的数据不一致问题？"><a href="#04-如何解决缓存和数据库的数据不一致问题？" class="headerlink" title="04 如何解决缓存和数据库的数据不一致问题？"></a>04 如何解决缓存和数据库的数据不一致问题？</h3><p> 缓存和数据库的数据不一致一般是由两个原因导致的，提供了相应的解决方案。</p>
<ul>
<li>删除缓存值或更新数据库失败而导致数据不一致，可以使用重试机制确保删除或更新操作成功。</li>
<li>在删除缓存值、更新数据库的这两步操作中，有其他线程的并发读操作，导致其他线程读取到旧值，应对方案是延迟双删。</li>
</ul>
<p>重试机制：具体来说，可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中。当应用没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。如果能够成功地删除或更新，我们就要把这些值从消息队列中去除，以免重复操作，此时，我们也可以保证数据库和缓存的数据一致了。否则的话，我们还需要再次进行重试。如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了 。</p>
<p>延迟双删： 一般<strong>应用于先删除缓存，再更新数据库的</strong>多线程并发访问的情况。这是因为，先更新数据库值，再删除缓存值的情况下，如果线程 A 删除了数据库中的值，但还没来得及删除缓存值，线程 B 就开始读取数据了，那么此时，线程 B 查询缓存时，发现缓存命中，就会直接从缓存中读取旧值。不过，在这种情况下，如果其他线程并发读缓存的请求不多，那么，就不会有很多请求读取到旧值。而且，线程 A 一般也会很快删除缓存值，这样一来，其他线程再次读取时，就会发生缓存缺失，进而从数据库中读取最新值。所以，这种情况对业务的影响较小。<br>总结：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i-blog.csdnimg.cn/blog_migrate/91383fbd6159fa4e6e47560870e18f54.png" alt="img"></p>
<h3 id="05-为什么使用了先删数据库再删缓存保证数据同步？"><a href="#05-为什么使用了先删数据库再删缓存保证数据同步？" class="headerlink" title="05 为什么使用了先删数据库再删缓存保证数据同步？"></a>05 为什么使用了先删数据库再删缓存保证数据同步？</h3><blockquote>
<p>在我的项目中，缓存和数据库的同步策略采用了“先更新数据库，再删除缓存”的方式，而不是“先删缓存再更新数据库”，主要是基于以下几点考虑：</p>
<p><strong>1. 避免数据不一致</strong><br>如果先删缓存，再更新数据库，在删除缓存后、更新数据库前，可能会有其他请求读取数据。由于缓存为空，这些请求会从数据库中读取旧数据并重新加载到缓存中。即使数据库更新完成，缓存中仍然是旧数据，导致缓存与数据库不一致。而在我的项目中，数据一致性是核心需求，因此优先保证数据库更新成功后再删除缓存。</p>
<p><strong>2. 减少缓存穿透风险</strong><br>先删缓存后，如果更新数据库的时间较长，在这段时间内可能会有大量请求直接穿透缓存，直接访问数据库，导致数据库压力骤增。我的项目是一个高并发系统，数据库的性能至关重要，因此需要避免这种风险。</p>
<p><del><strong>3. 简化并发控制</strong></del><br><del>在高并发场景下，如果先删缓存再更新数据库，可能会出现多个请求同时删除缓存并更新数据库的情况，导致数据竞争。而在我的项目中，通过“先更新数据库，再删除缓存”的方式，可以确保数据库更新成功后，缓存被删除，后续请求会重新加载最新数据，避免并发问题。</del></p>
<p><strong>4. 保证事务性</strong><br>我的项目中，数据库更新是一个事务性操作，确保数据更新的原子性。如果先删缓存，再更新数据库，在数据库更新失败的情况下，缓存已经被删除，会导致数据不一致。而“先更新数据库，再删除缓存”可以确保数据库更新成功后，缓存被删除，即使缓存删除失败，也可以通过重试机制保证最终一致性。</p>
<p><strong>5. 性能优化</strong><br>先更新数据库，再删除缓存，可以确保在数据库更新成功后，缓存被及时删除，减少缓存与数据库的同步延迟，提高系统的响应速度。这对于我的项目来说，是一个重要的性能优化点。</p>
<p>综上所述，在我的项目中，“先更新数据库，再删除缓存”的策略能够更好地保障数据一致性，减少缓存穿透风险，简化并发控制，并优化系统性能，因此选择了这种方案。</p>
</blockquote>
<h2 id="十五、项目中哪用了kafka？"><a href="#十五、项目中哪用了kafka？" class="headerlink" title="十五、项目中哪用了kafka？"></a>十五、项目中哪用了kafka？</h2><h3 id="01-怎么用了？"><a href="#01-怎么用了？" class="headerlink" title="01 怎么用了？"></a>01 怎么用了？</h3><blockquote>
<p>当有点赞，评论，关注请求时，会发送系统通知点赞，评论，关注的对象。在处理系统信息时，使用到了Kafka，具体来说，先定义了生产者类和消费者类，其中生产者被点赞/评论/关注功能对应的Controller使用，产生消息。而消费者负责消息（message）到来时，把消息存到数据库内。</p>
<p><strong>1. 生产者侧：用户触发事件，发消息到 Kafka</strong><br>比如用户A评论了用户B的帖子，后端会生成一条JSON消息，内容包含通知类型、发送人、接收人、帖子ID这些关键信息。然后通过Kafka生产者把这条消息发到对应的Topic里，比如评论通知单独一个Topic，点赞另一个。这里有个细节，我按接收人的用户ID做了分区，保证同一个用户的通知按顺序处理，避免乱序问题。</p>
<p><strong>3. 消费者侧：异步处理，存库+推送给用户</strong><br>消费者服务一直监听Kafka的Topic，拉取到新消息后，主要做两件事：</p>
<ul>
<li><strong>存数据库</strong>：把通知内容存到MySQL的<code>message</code>表，同时用Redis记录用户的未读通知数（比如小红点）。</li>
<li><strong>实时推送</strong>：如果用户在线，通过WebSocket立刻推前端；如果离线，等下次登录再拉取。</li>
</ul>
</blockquote>
<h3 id="02-生产者消费者模型"><a href="#02-生产者消费者模型" class="headerlink" title="02 生产者消费者模型"></a>02 生产者消费者模型</h3><blockquote>
<p><strong>生产者消费者模型</strong></p>
<p>Kafka 的生产者-消费者模型是一种高效的消息传递机制，生产者负责将消息发布到指定的 Kafka 主题（Topic），而消费者则从这些主题订阅并消费消息。Kafka 通过分区（Partition）和消费者组（Consumer Group）的设计，实现了高吞吐量和可扩展性。生产者可以异步发送消息，并支持消息确认机制，确保数据可靠性；消费者组内的多个消费者可以并行处理消息，Kafka 会为每个消费者分配特定的分区，保证消息的顺序性。这种模型解耦了生产者和消费者，适用于日志收集、实时数据处理和事件驱动架构等场景</p>
</blockquote>
<p><strong>kafka入门</strong></p>
<p>Apache Kafka是一个分布式流平台。一个分布式的流平台应该包含3点关键的能力：</p>
<p><strong>·kafka特点</strong></p>
<p><strong>-高吞吐量：</strong>处理TB级的海量数据</p>
<p>-消息持久化：持久化，将数据存储到硬盘上，而不仅仅存储在内存中，长久保存消息，存到硬盘中的读取速度远远小于内存，读写硬盘的效率高低取决于读取硬盘的方式，硬盘的顺序读写的效率是很高的，kafka保证对硬盘消息的读写都是顺序的；</p>
<p><strong>-高可靠性：</strong>kafka是分布式部署，一台服务器挂了，还有别的，有容错机制</p>
<p><strong>-高拓展性：</strong>集群的服务器不够时，可以扩展服务器，只需简单的配置</p>
<p><strong>·kafka术语</strong></p>
<p>消息模型：发布-订阅模型，消费者订阅了某一主题（topic）后，生产者采用类似广播的方式，将消息通过主题传递给所有的订阅者。<br>Topic：主题，类似于文件夹，用来存放不同的数据。<br>Partition：主题分区，同一主题的不同分区可以存放在不同的Broker上面，保证并发能力和负载均衡。<br>Offset：消息在Partition中的存放位置。<br>Broker：可以理解为kafka集群里面的一台或多台服务器，它本身是没有复制的，上面可能运行着topic1的leader， topic2的follower等等。</p>
<h3 id="02-消息队列放到内存还是磁盘？放磁盘为什么还这么快？"><a href="#02-消息队列放到内存还是磁盘？放磁盘为什么还这么快？" class="headerlink" title="02 消息队列放到内存还是磁盘？放磁盘为什么还这么快？"></a><strong>02 消息队列放到内存还是磁盘？放磁盘为什么还这么快？</strong></h3><p>Kafka的消息是保存或缓存在磁盘上的，一般认为在磁盘上读写数据是会降低性能的，因为寻址会比较消耗时间，但是实际上，Kafka的特性之一就是高吞吐率。</p>
<p>从数据写入和读取两方面分析，为什么Kafka速度这么快</p>
<p>写入数据：磁盘读写的快慢取决于你怎么使用它，也就是顺序读写或者随机读写。在<strong>顺序读写</strong>的情况下，磁盘的顺序读写速度和内存持平。因为硬盘是机械结构，每次读写都会寻址-&gt;写入，其中寻址是一个“机械动作”，它是最耗时的。所以硬盘最讨厌随机I/O，最喜欢顺序I/O。为了提高读写硬盘的速度，Kafka就是使用顺序I/O。</p>
<p>即便是顺序写入硬盘，硬盘的访问速度还是不可能追上内存。所以Kafka的数据并不是实时的写入硬盘 ，它充分利用了现代操作系统分页存储来利用内存提高I/O效率。</p>
<p>读取数据：实现了零拷贝，</p>
<p>传统数据读取的问题：传统的数据读取需要经过多次数据拷贝：</p>
<ol>
<li>从磁盘读取数据到内核缓冲区。</li>
<li>从内核缓冲区拷贝到用户空间缓冲区。</li>
<li>从用户空间缓冲区拷贝到内核的网络缓冲区。</li>
<li>从网络缓冲区发送到网络设备。</li>
</ol>
<p><strong>Kafka 的优化</strong>：Kafka 使用零拷贝技术（如 <code>sendfile</code> 系统调用），直接将数据从磁盘文件传输到网络设备，跳过了用户空间的拷贝。这样减少了 CPU 和内存的开销，提高了数据读取的效率。</p>
<h2 id="十六、Elasticsearch"><a href="#十六、Elasticsearch" class="headerlink" title="十六、Elasticsearch"></a>十六、Elasticsearch</h2><h3 id="01-Elasticsearch是什么"><a href="#01-Elasticsearch是什么" class="headerlink" title="01 Elasticsearch是什么"></a>01 Elasticsearch是什么</h3><p>Elasticsearch是由 ]ava语言开发<strong>基于Lucene</strong>的一款开源的搜索、聚合分析和存储引学。同时它也可以称作是一种<strong>非关系型文档数据库</strong>。（文档型数据库，它以 <strong>文档</strong> 为基本单位存储数据。文档通常采用 JSON、BSON 或 XML 等格式，每个文档是一个自包含的数据单元，包含键值对、嵌套对象或数组等结构。文档型数据库的核心思想是将数据以更自然的方式存储，而不是强制将其拆分为表和行。）</p>
<p>其具备天生分布式、高性能，高可用，易拓展，易维护，跨平台的特性，广泛应用于，海量数据的全文检索，搜索引擎，站内搜索等，还有日志系统ELK的使用也可以参与。</p>
<blockquote>
<p><del>概念：ES是一个基于lucene构建的，分布式的，RESTful的开源全文搜索引擎。</del><br><del>存储原理：数据按照Index – Type – Document – 字段四级存储，其中Index对应数据库，Type对应表，Document为搜索的原子单位，包含一个或多个容器，基于JSON表示。字段是指JSON中的每一项组成，类似于数据库中的行/列。Mapping是文档分析过滤后的结果，根据用户自定义，将某些文字过滤掉，类似于表结构定义DDL？？。同时ES也和分布式数据库一样，支持shard的replication。</del><br>功能：<br>1、分布式的搜索引擎和数据分析引擎<br>2、全文检索，结构化检索，数据分析。<br>3、对海量数据进行近实时的处理<br>特点：<br>1、可以作为分布式集群处理PB级别的数据，也可单机使用。<br>2、不是特有技术，而是将分布式+全文搜索（lucene) + 数据分析合并在一起。<br>3、操作简单，作为传统数据库的补充，提供了数据库所不具备的很多功能。</p>
</blockquote>
<h3 id="02-ES中的mapping是什么，ES的数据类型有哪些？"><a href="#02-ES中的mapping是什么，ES的数据类型有哪些？" class="headerlink" title="02 ES中的mapping是什么，ES的数据类型有哪些？"></a>02 ES中的mapping是什么，ES的数据类型有哪些？</h3><p>ES中的mapping有点类似于与RDB中“表结构”的概念，在MySQL中，表结构里包含了字段名称，字段的类型还有索引信息等。在Mapping里也包含了一些属性，比如字段名称、类型、字段使用的分词器、是否评分、是否创建索引等属性，并且在ES中一个字段可以有多个类型。<del>分词器、评分等念在后面的课程讲解。</del></p>
<p><strong>常见类型：</strong></p>
<ol>
<li><p><strong>数字类型：</strong>long integer  short   byte  double   float  half_float   scaled_float  unsigned_long</p>
</li>
<li><p><strong>Keyword类型：</strong>适用于索引结构化的字段，可以用于过滤、排序、聚合。keyword类型的字段只能通过精确值(exact value)搜索到。id应该用keyword。keyword字段通常用于排序，汇总和Term查询，例如term</p>
</li>
</ol>
<p>还有两个不常见的类型：</p>
<ul>
<li>constant_keyword:<strong>始终包含相同值的关键字字段</strong></li>
<li>wildcard:可针对类似grep的<strong>通配符查询</strong>优化日志行和类似的关键字值</li>
</ul>
<ol>
<li><strong>dates(时间类型)：</strong></li>
</ol>
<p>包括date和date_nanos</p>
<ol>
<li><strong>alias：</strong>为现有字段定义别名</li>
<li><u><strong>text:</strong>当一个字段是要被全文搜索的，比如Email内容、产品描述，这些字段应该使用text类型，设置text类型以后，字段内容会被分析，在生成倒排索引以前，字符串会被分析器分成一个一个词项。text类型的字段不用于排序，很少用于聚合。主要原因如下：</u></li>
</ol>
<ul>
<li><u><strong>分词问题</strong>：text 字段的内容会被分词，排序和聚合需要直接访问字段的原始值，而分词后的值无法直接用于这些操作。</u></li>
<li><u><strong>内存占用高</strong>：如果为 text 字段创建正排索引（用于排序和聚合），会占用大量堆空间，尤其是高基数字段（字段值非常多且不重复）。这会导致内存压力增加，甚至可能引发性能问题。</u></li>
<li><u><strong>加载成本高</strong>：加载正排索引是一个昂贵的操作，尤其是在字段值非常多的情况下，这会导致查询延迟增加，影响用户体验。</u></li>
<li><u><strong>生命周期长</strong>：正排索引一旦加载到内存中，就会在整个段的生命周期内驻留在内存中，即使不再使用，也不会被立即释放，进一步加剧内存压力。</u></li>
</ul>
<p>为了解决这个问题，通常的做法是：</p>
<ul>
<li>如果字段的值是短文本且不需要分词（如标签、状态码等），可以将其映射为 keyword 类型，keyword 类型字段会创建正排索引，支持排序和聚合。</li>
<li>如果需要同时支持全文搜索和排序/聚合，可以使用多字段映射（Multi-fields），例如将一个字段同时映射为 text 和 keyword 类型，分别用于全文搜索和排序/聚合。</li>
</ul>
<p>通过这种方式，Elasticsearch 在保证全文搜索性能的同时，避免了不必要的资源消耗。”</p>
<blockquote>
<h3 id="追问场景示例"><a href="#追问场景示例" class="headerlink" title="追问场景示例"></a><strong>追问场景示例</strong></h3><p><strong>面试官</strong>：你能举一个实际项目中如何使用多字段映射的例子吗？<br><strong>候选人</strong>：<br>“在电商项目中，我们有一个商品描述字段 <code>description</code>，需要同时支持全文搜索和排序。我们使用了多字段映射，将 <code>description</code> 字段映射为 text 和 keyword 类型：</p>
<ul>
<li><code>description</code> 字段用于全文搜索，支持分词和模糊查询。</li>
<li><code>description.keyword</code> 字段用于排序和聚合，存储原始值，支持精确匹配。</li>
</ul>
<p>例如，用户可以通过 <code>description</code> 字段搜索包含‘舒适’关键词的商品，同时通过 <code>description.keyword</code> 字段对商品描述进行字母顺序排序。这种方式既满足了全文搜索的需求，又支持了排序和聚合操作。”</p>
</blockquote>
<h3 id="03-项目中哪里使用到了ES-如何使用"><a href="#03-项目中哪里使用到了ES-如何使用" class="headerlink" title="03 项目中哪里使用到了ES,如何使用"></a>03 项目中哪里使用到了ES,如何使用</h3><p>在进行帖子搜索时，使用到了ES。可用Repository和Template两种方式，由于Repository搜索到的结果（直接返回的post类，方便）没有高亮标签（why），所以使用了template方式重写了mapResults函数，获得了带有高亮标签的post。<br>使用消息队列（kafka）的方式，实现发帖/删帖后ES数据库的自动更新。<br>搜索：定义SearchQuery，确定搜素内容，排序方式，高亮等。接着使用elasticTemplate.queryForPage方法，需要重写mapResults函数，得到高亮数据。</p>
<h2 id="十七、面经"><a href="#十七、面经" class="headerlink" title="十七、面经"></a>十七、面经</h2><h3 id="01-如何分析优化SQL执行效率？"><a href="#01-如何分析优化SQL执行效率？" class="headerlink" title="01 如何分析优化SQL执行效率？"></a>01 如何分析优化SQL执行效率？</h3><ol>
<li><strong>使用 <code>EXPLAIN</code> 分析执行计划</strong>：通过 <code>EXPLAIN</code> 命令查看 SQL 语句的执行计划，重点关注是否使用了索引、是否有全表扫描、连接类型（如 JOIN）是否高效等。通过分析执行计划，可以找到 SQL 的性能瓶颈。</li>
<li><strong>优化索引</strong>：确保查询条件中的字段有合适的索引，尤其是高频查询的字段。避免在索引列上使用函数或计算，这会导致索引失效。同时，注意避免创建过多索引，因为索引会增加写操作的开销。</li>
<li><strong>避免全表扫描</strong>：全表扫描会显著降低查询性能，应尽量通过索引或优化查询条件来避免。例如，使用 <code>WHERE</code> 条件筛选数据，或通过分页查询减少返回的数据量。</li>
<li><p><strong>优化查询语句</strong>：</p>
<ul>
<li>避免使用 <code>SELECT *</code>，只查询需要的字段，减少数据传输量。</li>
<li>减少子查询的使用，尽量用 JOIN 替代。</li>
<li>避免在 <code>WHERE</code> 条件中使用 <code>OR</code>，尤其是在不同字段上，这可能导致索引失效。</li>
</ul>
</li>
<li><p><strong>利用缓存</strong>：对于高频查询且数据变化不频繁的场景，可以使用 Redis 等缓存技术，减少数据库的访问压力。</p>
</li>
</ol>
<h3 id="02-EXPLAIN-中-type-字段的可能值及含义？"><a href="#02-EXPLAIN-中-type-字段的可能值及含义？" class="headerlink" title="02 EXPLAIN 中 type 字段的可能值及含义？"></a>02 <strong><code>EXPLAIN</code> 中 <code>type</code> 字段的可能值及含义？</strong></h3><p><code>type</code> 字段表示 MySQL 访问表的方式，常见的值及其含义如下：</p>
<ul>
<li><strong>system</strong>：表只有一行数据（系统表），是性能最高的访问方式。</li>
<li><strong>const</strong>：通过主键或唯一索引查询，返回一行数据。</li>
<li><strong>eq_ref</strong>：使用唯一索引进行关联查询，返回一行数据。</li>
<li><strong>ref</strong>：使用非唯一索引进行查询，返回多行数据。</li>
<li><strong>range</strong>：使用索引进行范围查询（如 <code>BETWEEN</code>、<code>&gt;</code>、<code>&lt;</code>）。</li>
<li><strong>index</strong>：全索引扫描，遍历整个索引树。</li>
<li><strong>ALL</strong>：全表扫描，性能最差，应尽量避免。</li>
</ul>
</article><!--//源文件--><!--if theme.post_copyright.enable && page.copyright !== false--><!--  - const author = page.copyright_author || config.author--><!--  - const authorHref = page.copyright_author_href || theme.post_copyright.author_href || config.url--><!--  - const url = page.copyright_url || page.permalink--><!--  - const info = page.copyright_info || _p('post.copyright.copyright_content', theme.post_copyright.license_url, theme.post_copyright.license, config.url, config.title)--><!--  .post-copyright--><!--    .post-copyright__author--><!--      span.post-copyright-meta--><!--        i.fas.fa-circle-user.fa-fw--><!--        = _p('post.copyright.author') + ": "--><!--      span.post-copyright-info--><!--        a(href=authorHref)= author--><!--    .post-copyright__type--><!--      span.post-copyright-meta--><!--        i.fas.fa-square-arrow-up-right.fa-fw--><!--        = _p('post.copyright.link') + ": "--><!--      span.post-copyright-info--><!--        a(href=url_for(url))= theme.post_copyright.decode ? decodeURI(url) : url--><!--    .post-copyright__notice--><!--      span.post-copyright-meta--><!--        i.fas.fa-circle-exclamation.fa-fw--><!--        = _p('post.copyright.copyright_notice') + ": "--><!--      span.post-copyright-info!= info--><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>仿牛客论坛项目——相关功能介绍</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="http://www.ccjinblog.top/2025/04/11/2025_4/00%20%E9%A1%B9%E7%9B%AE/">http://www.ccjinblog.top/2025/04/11/2025_4/00%20%E9%A1%B9%E7%9B%AE/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>未闻花名</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2025-04-11</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2026-02-08</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/%E5%B0%B1%E4%B8%9A/">就业</a></div><div class="post-share"><div class="social-share" data-image="https://source.fomal.cc/img/default_cover_4.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/02/07/2025_2/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%88%AC%E8%99%AB%E5%AE%8C%E7%BB%93/" title="毕业设计01_爬虫完结（爬取boss直聘数据）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ccjinblog.oss-cn-beijing.aliyuncs.com/blogiamge/20250110215903638.png" onerror="onerror=null;src='https://ccjinblog.oss-cn-beijing.aliyuncs.com/blogiamge/20241231104329441.gif'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">毕业设计01_爬虫完结（爬取boss直聘数据）</div></div><div class="info-2"><div class="info-item-1">爬虫部分没有记录笔记，爬虫中遇见的反爬中的问题见博客中的《Boss直聘反爬解决方法》 创建应用本项目采用Django框架，先创建一个新应用 输入python manage.py startapp myApp，创建一个新的 Django 应用（App） 生成的目录结构通常如下： 123456789myApp/    __init__.py # 这是一个空文件，用于告诉 Python 这个目录是一个 Python 包。    admin.py # 用于注册模型到 Django 的管理后台。    apps.py # 包含应用的配置信息。    migrations/ # 用于存放数据库迁移文件。        __init__.py    models.py # 用于定义数据库模型。    tests.py # 用于编写应用的测试用例。    views.py # 用于编写视图函数或类。 定义数据库模型 在 models.py 文件中，定义了三个 Django 模型：JobInfo、User 和...</div></div></div></a><a class="pagination-related" href="/2025/04/11/2025_4/01%20spring/" title="spring面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_1.webp" onerror="onerror=null;src='https://ccjinblog.oss-cn-beijing.aliyuncs.com/blogiamge/20241231104329441.gif'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">spring面试题</div></div><div class="info-2"><div class="info-item-1">牛客论坛01-Spring常见面试题Spring中的IoC和AOP是什么？它们的作用是什么？ IoC（Inversion of Control:控制反转） 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。所以说，控制反转是一种思想，目的是为了降低了代码耦合度，提升了系统的灵活性和可维护性。 在没有IoC容器的情况下，比如类A通过new关键字直接实例化类B，对象创建和依赖关系由开发者手动控制，代码耦合度高，难以维护和扩展。而在有IoC容器的情况下，IoC容器负责实例化类A和类B，并管理它们的依赖关系，主函数只需从容器中获取所需对象，无需手动创建。 所谓控制，就是指的是对象的创建（实例化，管理什么的），反转指的是将控制权交给外部框架（spring框架，IoC容器）。IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。在实际项目中一个 Service...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/11/2025_4/01%20spring/" title="spring面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_1.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-11</div><div class="info-item-2">spring面试题</div></div><div class="info-2"><div class="info-item-1">牛客论坛01-Spring常见面试题Spring中的IoC和AOP是什么？它们的作用是什么？ IoC（Inversion of Control:控制反转） 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。所以说，控制反转是一种思想，目的是为了降低了代码耦合度，提升了系统的灵活性和可维护性。 在没有IoC容器的情况下，比如类A通过new关键字直接实例化类B，对象创建和依赖关系由开发者手动控制，代码耦合度高，难以维护和扩展。而在有IoC容器的情况下，IoC容器负责实例化类A和类B，并管理它们的依赖关系，主函数只需从容器中获取所需对象，无需手动创建。 所谓控制，就是指的是对象的创建（实例化，管理什么的），反转指的是将控制权交给外部框架（spring框架，IoC容器）。IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。在实际项目中一个 Service...</div></div></div></a><a class="pagination-related" href="/2026/01/16/2026_1/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" title="java基础语法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ccjinblog.oss-cn-beijing.aliyuncs.com/blogiamge/20241231112245840.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-16</div><div class="info-item-2">java基础语法</div></div><div class="info-2"><div class="info-item-1">Java基础语法（1）集合常用的方法： List添加元素：  12345678List&lt;Integer&gt; res = new ArrayList&lt;&gt;();int val[] = new int[]&#123;1, 2, 3, 4, 5&#125;;for (int i = 0; i &lt; val.length; i++) &#123;    res.add(val[i]);&#125;System.out.println(res);//输出结果：[1, 2, 3, 4, 5] </div></div></div></a><a class="pagination-related" href="/2025/04/11/2025_4/02%20mysql/" title="mysql面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_7.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-11</div><div class="info-item-2">mysql面试题</div></div><div class="info-2"><div class="info-item-1">Mysql索引01 什么时索引？为什么要使用索引？ 官方介绍索引是帮助MySQL高效获取数据的数据结构。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。  一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中的（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。  我们通常所说的索引，包括聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等，没有特别说明，默认都是使用B+树结构组织（多路搜索树，并不一定是二叉的）的索引。   02 常见的索引类型？ 主键索引  索引列中的值必须是唯一的，不允许有空值。  普通索引  MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。  唯一索引  索引列中的值必须是唯一的，但是允许为空值。  全文索引  只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。...</div></div></div></a><a class="pagination-related" href="/2026/01/28/2026_1/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="力扣算法题hot100"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ccjinblog.oss-cn-beijing.aliyuncs.com/blogiamge/20250113225409777.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-28</div><div class="info-item-2">力扣算法题hot100</div></div><div class="info-2"><div class="info-item-1">二叉树（1）二叉树的中序遍历：题目链接🍳  算法思路： 使用递归实现的二叉树中序遍历算法，按照 “左子树 → 根节点 → 右子树” （LNR）的顺序遍历所有节点，并将节点的值收集到一个列表中返回（因为返回值类型为List&lt;Integer&gt;）。  12345678910111213141516class Solution &#123;    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();        inorder(root, res);        return res;    &#125;        public void inorder(TreeNode root, List&lt;Integer&gt; res)&#123;        if(root == null)&#123;            return;       ...</div></div></div></a><a class="pagination-related" href="/2025/04/11/2025_4/03%20redis/" title="redis面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ccjinblog.oss-cn-beijing.aliyuncs.com/blogiamge/20250109115722416.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-11</div><div class="info-item-2">redis面试题</div></div><div class="info-2"><div class="info-item-1">redis01 什么是redis？Redis是一种基于内存的数据库，对数据的读写操作都非常快，常用于缓存，消息队列，分布式锁等场景。其内部提供了多种不同的数据类型来支持不同的业务场景，比如String, Hash, List, Set, Zset, BitMap, HyperLogLog, GEO, Stream，并且对数据类型的操作都是原子性的，因为执行命令由单线程负责，不存在并发竞争的问题。除此之外，Redis还支持事务，持久化，Lua脚本，多种集群方案（主从复制模式/哨兵模式，切片集群模式），发布/订阅模式，内存淘汰机制，过期删除机制。 02...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ccjinblog.oss-cn-beijing.aliyuncs.com/blogiamge/20250123182424614.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">未闻花名</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com//2022cheng" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:chujin.cheng@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/config/img/wechat.jpg" target="_blank" title="Wechat"><i class="fa-brands fa-weixin" style="color: #00c800;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center><b>--- 主域名 ---<br><a href="https://www.ccjinblog.top" title="此线路部署于Vercel" class="anno_content"><font color="#5ea6e5">ccjinblog.top</font></a><br>--- CSDN博客 ---<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_62074330?spm=1000.2115.3001.5343" title="访问我的CSDN博客" class="anno_content"><font color="#5ea6e5">CSDN博客</font></a><br>--- 博客园 ---<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/-2022zbdxgitee" title="访问我的博客园" class="anno_content"><font color="#5ea6e5">博客园</font></a></b></center></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">项目相关功能介绍：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E9%A1%B9%E7%9B%AE%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">介绍一下项目：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">一、 发送邮件功能：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E4%BD%A0%E5%A6%82%E4%BD%95%E5%9C%A8-Spring-Boot-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">01 你如何在 Spring Boot 项目中实现发送邮件的功能？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E9%82%AE%E7%AE%B1%E6%9C%8D%E5%8A%A1%EF%BC%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">02 如何配置邮箱服务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-%E4%BD%A0%E5%A6%82%E4%BD%95%E5%8F%91%E9%80%81-HTML-%E6%A0%BC%E5%BC%8F%E7%9A%84%E9%82%AE%E4%BB%B6%EF%BC%9F"><span class="toc-number">1.2.3.</span> <span class="toc-text">03 你如何发送 HTML 格式的邮件？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD"><span class="toc-number">1.3.</span> <span class="toc-text">二、注册功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">01 注册功能的开发流程吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81%E4%B8%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.3.2.</span> <span class="toc-text">02 数据验证与错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E4%B8%8E%E6%BF%80%E6%B4%BB%E5%8A%9F%E8%83%BD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">03 邮件发送与激活功能如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%EF%BC%9F"><span class="toc-number">1.3.4.</span> <span class="toc-text">04 如何使用模板引擎实现的代码复用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">三、 会话管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E8%A7%A3%E9%87%8AHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%97%A0%E7%8A%B6%E6%80%81%E6%80%A7%EF%BC%8C%E5%B9%B6%E8%AF%B4%E6%98%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8Web%E5%BC%80%E5%8F%91%E4%B8%AD%E9%9C%80%E8%A6%81%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%EF%BC%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">01 解释HTTP协议的无状态性，并说明为什么在Web开发中需要会话管理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-%E8%AF%B7%E8%A7%A3%E9%87%8ACookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%B9%B6%E8%AF%B4%E6%98%8E%E5%AE%83%E4%BB%AC%E5%90%84%E8%87%AA%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">1.4.2.</span> <span class="toc-text">02 请解释Cookie和Session的区别，并说明它们各自的适用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Session%E4%B8%8D%E5%85%B1%E4%BA%AB%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.4.3.</span> <span class="toc-text">03 在分布式部署中，如何解决Session不共享的问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8Redis%E6%9D%A5%E5%AD%98%E5%82%A8Session%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">1.4.4.</span> <span class="toc-text">04 为什么在分布式系统中推荐使用Redis来存储Session数据？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-%E5%9C%A8Java%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASession%E5%B9%B6%E5%AD%98%E5%82%A8%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">1.4.5.</span> <span class="toc-text">05 在Java中，如何创建一个Session并存储用户数据？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%AA%8C%E8%AF%81%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">1.5.</span> <span class="toc-text">四、验证码生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.5.1.</span> <span class="toc-text">01 验证码功能实现介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-capture%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.5.2.</span> <span class="toc-text">02 capture工具介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-capture%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.5.3.</span> <span class="toc-text">03 capture工具的使用步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-%E8%AF%B7%E8%A7%A3%E9%87%8A%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%9F"><span class="toc-number">1.5.4.</span> <span class="toc-text">04 请解释验证码的作用以及为什么在登录页面中使用验证码？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-%E8%AF%B7%E6%8F%8F%E8%BF%B0%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8capture%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%8C%E5%B9%B6%E8%AF%B4%E6%98%8E%E5%85%B6%E6%A0%B8%E5%BF%83%E6%AD%A5%E9%AA%A4%E3%80%82"><span class="toc-number">1.5.5.</span> <span class="toc-text">05 请描述如何使用capture工具生成验证码，并说明其核心步骤。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#06-%E5%9C%A8%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E8%83%BD%E5%A4%9F%E8%A2%AB%E5%90%8E%E7%BB%AD%E8%AF%B7%E6%B1%82%E9%AA%8C%E8%AF%81%EF%BC%9F"><span class="toc-number">1.5.6.</span> <span class="toc-text">06 在生成验证码时，如何确保验证码的字符能够被后续请求验证？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#07-%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E8%83%BD%E5%A4%9F%E5%9C%A8%E4%B8%8D%E5%90%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%EF%BC%9F"><span class="toc-number">1.5.7.</span> <span class="toc-text">07 在分布式系统中，如何确保验证码的字符能够在不同服务器之间共享？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#08-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">1.5.8.</span> <span class="toc-text">08 如何实现验证码的动态刷新功能？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%99%BB%E5%BD%95%EF%BC%8C%E9%80%80%E5%87%BA%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.</span> <span class="toc-text">五、登录，退出功能实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E8%AF%B7%E6%8F%8F%E8%BF%B0%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.6.1.</span> <span class="toc-text">01 请描述登录功能的实现流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E7%99%BB%E5%BD%95%E5%87%AD%E8%AF%81%E8%80%8C%E4%B8%8D%E6%98%AFSession%EF%BC%9F"><span class="toc-number">1.6.2.</span> <span class="toc-text">02 为什么选择数据库存储登录凭证而不是Session？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8login-ticket%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.6.3.</span> <span class="toc-text">03 数据库表login_ticket的设计思路是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%E8%A2%AB%E7%BB%95%E8%BF%87%EF%BC%9F"><span class="toc-number">1.6.4.</span> <span class="toc-text">04 验证码的作用是什么？如何防止验证码被绕过？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-%E9%80%80%E5%87%BA%E5%8A%9F%E8%83%BD%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E7%94%A8%E6%88%B7%E5%AE%8C%E5%85%A8%E7%99%BB%E5%87%BA%EF%BC%9F"><span class="toc-number">1.6.5.</span> <span class="toc-text">05 退出功能如何确保用户完全登出？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#06-%E5%A6%82%E6%9E%9C%E7%94%A8%E6%88%B7%E5%90%8C%E6%97%B6%E5%9C%A8%E5%A4%9A%E8%AE%BE%E5%A4%87%E7%99%BB%E5%BD%95%EF%BC%8C%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">1.6.6.</span> <span class="toc-text">06. 如果用户同时在多设备登录，系统如何处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#07-MyBatis%E4%B8%AD%E6%B3%A8%E8%A7%A3%E5%92%8CXML%E9%85%8D%E7%BD%AE%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-number">1.6.7.</span> <span class="toc-text">07. MyBatis中注解和XML配置如何选择？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%99%BB%E5%BD%95%E9%80%80%E5%87%BA%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.</span> <span class="toc-text">六、登录退出功能的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E8%AF%B7%E8%AF%B4%E6%98%8E%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">1.7.1.</span> <span class="toc-text">01 请说明如何利用拦截器实现登录信息的统一处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9ThreadLocal%E5%AD%98%E5%82%A8%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-number">1.7.2.</span> <span class="toc-text">02 为什么选择ThreadLocal存储用户数据？如何避免内存泄漏？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E4%BB%AC%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">1.7.3.</span> <span class="toc-text">03 拦截器的三个核心方法分别是什么？它们的执行顺序是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-%E5%A6%82%E6%9E%9C%E6%8B%A6%E6%88%AA%E5%99%A8%E8%AF%AF%E6%8B%A6%E6%88%AA%E4%BA%86%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%EF%BC%88%E5%A6%82CSS%E3%80%81JS%E6%96%87%E4%BB%B6%EF%BC%89%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">1.7.4.</span> <span class="toc-text">04 如果拦截器误拦截了静态资源（如CSS、JS文件），如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-%E7%94%A8%E6%88%B7%E6%9C%AA%E7%99%BB%E5%BD%95%E5%92%8C%E5%B7%B2%E7%99%BB%E5%BD%95%E6%97%B6%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%A4%B4%E9%83%A8%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%90%8C%E5%86%85%E5%AE%B9%EF%BC%9F"><span class="toc-number">1.7.5.</span> <span class="toc-text">05 用户未登录和已登录时，页面头部如何动态显示不同内容？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#06-%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E7%94%A8%E6%88%B7%E5%87%AD%E8%AF%81%EF%BC%88ticket%EF%BC%89%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9F"><span class="toc-number">1.7.6.</span> <span class="toc-text">06 如何确保用户凭证（ticket）的安全性？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%A4%B4%E5%83%8F%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">1.8.</span> <span class="toc-text">七、头像上传功能如何实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81%E6%A3%80%E6%9F%A5"><span class="toc-number">1.9.</span> <span class="toc-text">八、登录状态检查</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E4%BD%A0%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%A3%80%E6%9F%A5%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81%E7%9A%84%E5%8A%9F%E8%83%BD%E5%90%97%EF%BC%9F"><span class="toc-number">1.9.1.</span> <span class="toc-text">01 你能解释一下如何实现检查登录状态的功能吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-%E4%BD%A0%E8%83%BD%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E6%8B%A6%E6%88%AA%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">1.9.2.</span> <span class="toc-text">02 你能详细解释一下拦截器是如何工作的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-%E4%BD%A0%E6%8F%90%E5%88%B0%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%EF%BC%8C%E4%BD%A0%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8%E5%AE%83%E5%90%97%EF%BC%9F"><span class="toc-number">1.9.3.</span> <span class="toc-text">03 你提到使用自定义注解，你能解释一下如何定义和使用它吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4"><span class="toc-number">1.10.</span> <span class="toc-text">九、敏感词过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD"><span class="toc-number">1.10.1.</span> <span class="toc-text">01 如何实现的敏感词过滤功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-%E8%A7%86%E9%A2%91%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.10.2.</span> <span class="toc-text">02 视频功能实现的功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81-%E5%8F%91%E5%B8%83%E5%B8%96%E5%AD%90"><span class="toc-number">1.11.</span> <span class="toc-text">十、 发布帖子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8F%91%E5%B8%83%E5%B8%96%E5%AD%90%EF%BC%9F"><span class="toc-number">1.11.1.</span> <span class="toc-text">01 如何实现的发布帖子？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E8%AF%9D%E6%9C%AF"><span class="toc-number">1.11.2.</span> <span class="toc-text">面试回答话术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%B8%96%E5%AD%90%E8%AF%A6%E6%83%85%E3%80%81%E6%98%BE%E7%A4%BA%E8%AF%84%E8%AE%BA"><span class="toc-number">1.12.</span> <span class="toc-text">十一、帖子详情、显示评论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E8%AF%B7%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AE%9E%E7%8E%B0%E7%9A%84%E2%80%9C%E5%B8%96%E5%AD%90%E8%AF%A6%E6%83%85%E2%80%9D%E5%8A%9F%E8%83%BD%E3%80%82"><span class="toc-number">1.12.1.</span> <span class="toc-text">01 请描述一下你实现的“帖子详情”功能。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA"><span class="toc-number">1.13.</span> <span class="toc-text">十二、添加评论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E7%A7%81%E4%BF%A1%E5%88%97%E8%A1%A8%E5%92%8C%E7%A7%81%E4%BF%A1%E8%AF%A6%E6%83%85"><span class="toc-number">1.14.</span> <span class="toc-text">十三、私信列表和私信详情</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A7%81%E4%BF%A1%E5%88%97%E8%A1%A8"><span class="toc-number">1.14.1.</span> <span class="toc-text">1.私信列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A7%81%E4%BF%A1%E8%AF%A6%E6%83%85"><span class="toc-number">1.14.2.</span> <span class="toc-text">2.私信详情</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84redis%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">1.15.</span> <span class="toc-text">十四、项目中的redis如何使用的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.15.1.</span> <span class="toc-text">01 使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E7%BB%9F%E8%AE%A1%E7%BD%91%E7%AB%99UA%E5%92%8CDAU"><span class="toc-number">1.15.1.1.</span> <span class="toc-text">统计统计网站UA和DAU</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-redis%E7%9A%84key%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%EF%BC%88%E6%80%8E%E6%A0%B7%E5%AD%98%E5%82%A8%E7%9A%84%E7%82%B9%E8%B5%9E%E3%80%81%E5%85%B3%E6%B3%A8%E3%80%81%E7%BC%93%E5%AD%98%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%EF%BC%89%EF%BC%9F"><span class="toc-number">1.15.2.</span> <span class="toc-text">02 redis的key怎么设计（怎样存储的点赞、关注、缓存用户数据）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-%E7%BC%93%E5%AD%98%E7%82%B9%E8%B5%9E%E6%95%B0%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.15.3.</span> <span class="toc-text">03 缓存点赞数如何实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.15.4.</span> <span class="toc-text">04 如何解决缓存和数据库的数据不一致问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E4%BA%86%E5%85%88%E5%88%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%8D%E5%88%A0%E7%BC%93%E5%AD%98%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="toc-number">1.15.5.</span> <span class="toc-text">05 为什么使用了先删数据库再删缓存保证数据同步？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%E3%80%81%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%93%AA%E7%94%A8%E4%BA%86kafka%EF%BC%9F"><span class="toc-number">1.16.</span> <span class="toc-text">十五、项目中哪用了kafka？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E6%80%8E%E4%B9%88%E7%94%A8%E4%BA%86%EF%BC%9F"><span class="toc-number">1.16.1.</span> <span class="toc-text">01 怎么用了？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.16.2.</span> <span class="toc-text">02 生产者消费者模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%94%BE%E5%88%B0%E5%86%85%E5%AD%98%E8%BF%98%E6%98%AF%E7%A3%81%E7%9B%98%EF%BC%9F%E6%94%BE%E7%A3%81%E7%9B%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">1.16.3.</span> <span class="toc-text">02 消息队列放到内存还是磁盘？放磁盘为什么还这么快？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E3%80%81Elasticsearch"><span class="toc-number">1.17.</span> <span class="toc-text">十六、Elasticsearch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-Elasticsearch%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.17.1.</span> <span class="toc-text">01 Elasticsearch是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-ES%E4%B8%AD%E7%9A%84mapping%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8CES%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.17.2.</span> <span class="toc-text">02 ES中的mapping是什么，ES的数据类型有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.17.3.</span> <span class="toc-text">追问场景示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%93%AA%E9%87%8C%E4%BD%BF%E7%94%A8%E5%88%B0%E4%BA%86ES-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">1.17.4.</span> <span class="toc-text">03 项目中哪里使用到了ES,如何使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%83%E3%80%81%E9%9D%A2%E7%BB%8F"><span class="toc-number">1.18.</span> <span class="toc-text">十七、面经</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96SQL%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%EF%BC%9F"><span class="toc-number">1.18.1.</span> <span class="toc-text">01 如何分析优化SQL执行效率？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-EXPLAIN-%E4%B8%AD-type-%E5%AD%97%E6%AE%B5%E7%9A%84%E5%8F%AF%E8%83%BD%E5%80%BC%E5%8F%8A%E5%90%AB%E4%B9%89%EF%BC%9F"><span class="toc-number">1.18.2.</span> <span class="toc-text">02 EXPLAIN 中 type 字段的可能值及含义？</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(https://source.fomal.cc/img/default_cover_4.webp);"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2026 By 未闻花名</div><div class="footer_custom_text">如果有一天，你不再寻找爱情，只是去爱；你不再渴望成功，只是去做；你不再追求空泛的成长，只是开始修养自己的性情；你的人生一切，才真正开始。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script async src="/config/js/title.js"></script><script async src="/config/js/fps.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://www.ccjinblog.top/categories/java/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 未闻花名のjava学习 (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.ccjinblog.top/categories/博客/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 未闻花名の魔改教程 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.ccjinblog.top/categories/生活/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱‍👓 未闻花名の生活趣闻 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.ccjinblog.top/categories/毕业设计/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 未闻花名の毕业设计 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.ccjinblog.top/categories/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 未闻花名の算法学习 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="http://www.ccjinblog.top/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://dashboard.4everland.org/" style="margin-inline:5px" data-title="本站采用多线部署，备用线路托管于4EVERLAND" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2026/02/03/2026_2/Claude安装使用教程/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_8.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2026-02-03</span><a class="blog-slider__title" href="2026/02/03/2026_2/Claude安装使用教程/" alt="">Claude Code 使用教程</a><div class="blog-slider__text">描述Claude Code 使用教程</div><a class="blog-slider__button" href="2026/02/03/2026_2/Claude安装使用教程/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2026/02/08/2026_2/uv的使用/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ccjinblog.oss-cn-beijing.aliyuncs.com/blogiamge/20250110215903642.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2026-02-08</span><a class="blog-slider__title" href="2026/02/08/2026_2/uv的使用/" alt="">UV Python 环境管理完全指南</a><div class="blog-slider__text">UV Python 环境管理完全指南</div><a class="blog-slider__button" href="2026/02/08/2026_2/uv的使用/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/05/21/2025_5/论文/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_3.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-05-21</span><a class="blog-slider__title" href="2025/05/21/2025_5/论文/" alt="">毕业设计02_论文</a><div class="blog-slider__text">对毕业设计的论文相关书写进行记录</div><a class="blog-slider__button" href="2025/05/21/2025_5/论文/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/02/07/2025_2/毕业设计爬虫完结/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ccjinblog.oss-cn-beijing.aliyuncs.com/blogiamge/20250110215903638.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-02-07</span><a class="blog-slider__title" href="2025/02/07/2025_2/毕业设计爬虫完结/" alt="">毕业设计01_爬虫完结（爬取boss直聘数据）</a><div class="blog-slider__text">对毕业设计的爬虫部分后续操作进行记录</div><a class="blog-slider__button" href="2025/02/07/2025_2/毕业设计爬虫完结/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/01/20/2025_1/butterfly魔改教程1/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ccjinblog.oss-cn-beijing.aliyuncs.com/blogiamge/20250109115722416.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-01-20</span><a class="blog-slider__title" href="2025/01/20/2025_1/butterfly魔改教程1/" alt="">butterfly魔改教程（一）</a><div class="blog-slider__text">对hexo博客的butterfly主题进行美化</div><a class="blog-slider__button" href="2025/01/20/2025_1/butterfly魔改教程1/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/01/24/2025_1/butterfly魔改教程2/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_4.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-01-24</span><a class="blog-slider__title" href="2025/01/24/2025_1/butterfly魔改教程2/" alt="">butterfly魔改教程（二）</a><div class="blog-slider__text">对hexo博客的butterfly主题进行美化</div><a class="blog-slider__button" href="2025/01/24/2025_1/butterfly魔改教程2/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2025/01/15/2025_1/Ubuntu系统基础操作和使用/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_4.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-01-15</span><a class="blog-slider__title" href="2025/01/15/2025_1/Ubuntu系统基础操作和使用/" alt="">Ubuntu系统基础操作和使用</a><div class="blog-slider__text">Ubuntu系统基础操作和使用</div><a class="blog-slider__button" href="2025/01/15/2025_1/Ubuntu系统基础操作和使用/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>